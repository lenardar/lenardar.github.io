<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="参考文献 2  Data and Basic Modeling – Applied Machine Learning Using mlr3 in R  已经在Workflow已简单介绍了一下建模流程，本节具体介绍一下基础建模，主要是翻译官方文档，哈哈哈。 先看一下机器学习的总体建模流程，先分割数据集为训练集与测试集，使用训练集训练学习器得到训练好的模型，在测试集上预测结果，与测试集结果比较评价">
<meta property="og:type" content="article">
<meta property="og:title" content="mlr3verse 基础建模">
<meta property="og:url" content="http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/index.html">
<meta property="og:site_name" content="Lenardar&#39;s Blog">
<meta property="og:description" content="参考文献 2  Data and Basic Modeling – Applied Machine Learning Using mlr3 in R  已经在Workflow已简单介绍了一下建模流程，本节具体介绍一下基础建模，主要是翻译官方文档，哈哈哈。 先看一下机器学习的总体建模流程，先分割数据集为训练集与测试集，使用训练集训练学习器得到训练好的模型，在测试集上预测结果，与测试集结果比较评价">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/unsplash-HDBHINxGccQ-20250518185627-hzu5mqv.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115559437.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115638066.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115700564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115719054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115802226.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115819861.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115838360.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115856582.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115913284.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115931052.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115950141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120006073.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120021579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120035078.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120049409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120101340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120115043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120128191.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120142559.png">
<meta property="article:published_time" content="2025-05-19T03:44:43.000Z">
<meta property="article:modified_time" content="2025-05-19T04:03:27.152Z">
<meta property="article:author" content="Lenardar">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="机器学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/unsplash-HDBHINxGccQ-20250518185627-hzu5mqv.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>mlr3verse 基础建模</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/lenardar">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/05/24/MacBook-%E5%BE%AE%E4%BF%A1%E6%96%87%E4%BB%B6%E4%BA%91%E5%A4%87%E4%BB%BD/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/05/18/mlr3verse-workflow/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&text=mlr3verse 基础建模"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&is_video=false&description=mlr3verse 基础建模"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=mlr3verse 基础建模&body=Check out this article: http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&name=mlr3verse 基础建模&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&t=mlr3verse 基础建模"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%EF%BC%88Task%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">任务（Task）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">构建任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2"><span class="toc-number">1.2.</span> <span class="toc-text">数据检索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">修改任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%99%A8%EF%BC%88Learners%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">学习器（Learners）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83"><span class="toc-number">2.1.</span> <span class="toc-text">训练</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86"><span class="toc-number">2.2.</span> <span class="toc-text">数据集划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B"><span class="toc-number">2.3.</span> <span class="toc-text">预测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E9%A2%84%E6%B5%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">更改预测类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">超参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Paradox-%E4%B8%8E%E5%8F%82%E6%95%B0%E9%9B%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">Paradox 与参数集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%AE%BE%E7%BD%AE%E8%B6%85%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">2.5.2.</span> <span class="toc-text">获取与设置超参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.3.</span> <span class="toc-text">超参数依赖关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%BA%BF%E5%AD%A6%E4%B9%A0%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">基线学习器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0"><span class="toc-number">3.</span> <span class="toc-text">评估</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">度量指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%BE%97%E5%88%86"><span class="toc-number">3.2.</span> <span class="toc-text">预测得分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">3.3.</span> <span class="toc-text">技术指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%9B%9E%E5%BD%92"><span class="toc-number">4.</span> <span class="toc-text">测试回归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%EF%BC%88Classification%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">分类（Classification）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">测试分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.2.</span> <span class="toc-text">分类任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0%E5%99%A8%E4%B8%8E%E5%88%86%E7%B1%BB%E5%BA%A6%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">分类学习器与分类度量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PredictionClassif-%E3%80%81%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%98%88%E5%80%BC%E8%AE%BE%E5%AE%9A"><span class="toc-number">5.4.</span> <span class="toc-text">PredictionClassif 、混淆矩阵与阈值设定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5"><span class="toc-number">5.4.1.</span> <span class="toc-text">混淆矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E9%98%88%E5%80%BC"><span class="toc-number">5.4.2.</span> <span class="toc-text">设定阈值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A7%92%E8%89%B2%EF%BC%88Task-Column-Roles%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">任务列角色（Task Column Roles）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">8.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01"><span class="toc-number">8.1.</span> <span class="toc-text">练习1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02"><span class="toc-number">8.2.</span> <span class="toc-text">练习2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A03"><span class="toc-number">8.3.</span> <span class="toc-text">练习3</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        mlr3verse 基础建模
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Lenardar</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-05-19T03:44:43.000Z" class="dt-published" itemprop="datePublished">2025-05-19</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a>, <a class="p-category" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/unsplash-HDBHINxGccQ-20250518185627-hzu5mqv.jpg" alt="img"></p>
<blockquote>
<p><strong>参考文献</strong></p>
<p><a target="_blank" rel="noopener" href="https://mlr3book.mlr-org.com/chapters/chapter2/data_and_basic_modeling.html#sec-classif">2  Data and Basic Modeling – Applied Machine Learning Using mlr3 in R</a></p>
</blockquote>
<p>已经在Workflow已简单介绍了一下建模流程，本节具体介绍一下基础建模，主要是翻译官方文档，哈哈哈。</p>
<p>先看一下机器学习的总体建模流程，先分割数据集为训练集与测试集，使用训练集训练学习器得到训练好的模型，在测试集上预测结果，与测试集结果比较评价模型，最终输出性能。</p>
<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115559437.png"></p>
<p>在mlr3中工作流如下：</p>
<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115638066.png"></p>
<h1 id="任务（Task）"><a href="#任务（Task）" class="headerlink" title="任务（Task）"></a>任务（Task）</h1><p>任务（Tasks）是包含（通常为表格形式的）数据及定义机器学习问题的附加元数据的对象。元数据中包括例如监督式机器学习问题的目标特征名称等信息（也就是$y$）。这些信息在需要时会自动提取，因此用户在每次训练模型时无需重复指定预测目标。</p>
<h2 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h2><p><code>mlr3</code> 包含了 <code>mlr_tasks</code> <code>Dictionary</code> 中一些预定义的机器学习任务。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mlr3verse<span class="punctuation">)</span></span><br><span class="line">mlr_tasks</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;DictionaryTask&gt; with 22 stored values</span></span><br><span class="line"><span class="comment"># Keys: ames_housing, bike_sharing, boston_housing, breast_cancer,</span></span><br><span class="line"><span class="comment">#   california_housing, german_credit, ilpd, iris, kc_housing, moneyball,</span></span><br><span class="line"><span class="comment">#   mtcars, optdigits, penguins, penguins_simple, pima, ruspini, sonar,</span></span><br><span class="line"><span class="comment">#   spam, titanic, usarrests, wine, zoo</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>tsk()</code> 函数提取变量名对应的任务。下面我们检索 <code>tsk(&quot;mtcars&quot;)</code> ，它使用了 <code>mtcars </code>数据集：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tsk_mtcars <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;TaskRegr:mtcars&gt; (32 x 11): Motor Trends</span></span><br><span class="line"><span class="comment"># * Target: mpg</span></span><br><span class="line"><span class="comment"># * Properties: -</span></span><br><span class="line"><span class="comment"># * Features (10):</span></span><br><span class="line"><span class="comment">#   - dbl (10): am, carb, cyl, disp, drat, gear, hp, qsec, vs, wt</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>tsk()</code> 时不带任何参数将列出字典中的所有任务：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tsk<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;DictionaryTask&gt; with 22 stored values</span></span><br><span class="line"><span class="comment"># Keys: ames_housing, bike_sharing, boston_housing, breast_cancer,</span></span><br><span class="line"><span class="comment">#   california_housing, german_credit, ilpd, iris, kc_housing, moneyball,</span></span><br><span class="line"><span class="comment">#   mtcars, optdigits, penguins, penguins_simple, pima, ruspini, sonar,</span></span><br><span class="line"><span class="comment">#   spam, titanic, usarrests, wine, zoo</span></span><br></pre></td></tr></table></figure>

<p>要创建自己的回归任务，需要构造一个新的 <code>TaskRegr</code> 实例。最简单的方法是使用 <code>as_task_regr()</code> 函数将 <code>data.frame</code> 类型的对象转换为回归任务，并通过 <code>target</code> 参数指定目标特征。</p>
<p>在下面的代码中，我们加载 <code>datasets::mtcars</code> 数据集，筛选数据仅包含 <code>&quot;mpg&quot;</code> 、 <code>&quot;cyl&quot;</code> 、 <code>&quot;disp&quot;</code> 列，打印修改后数据的属性，然后设置一个名为 <code>&quot;cars&quot;</code> （ <code>id = &quot;cars&quot;</code> ）的回归任务，在该任务中我们将尝试根据气缸数（ <code>&quot;cyl&quot;</code> ）和排量（ <code>&quot;disp&quot;</code> ）来预测每加仑英里数（ <code>target = &quot;mpg&quot;</code> ）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;datasets&quot;</span><span class="punctuation">)</span></span><br><span class="line">mtcars_subset <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>mtcars<span class="punctuation">,</span> select <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> <span class="string">&quot;disp&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">str<span class="punctuation">(</span>mtcars_subset<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;data.frame&#x27;:	32 obs. of  3 variables:</span></span><br><span class="line"><span class="comment">#  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...</span></span><br><span class="line"><span class="comment">#  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...</span></span><br><span class="line"><span class="comment">#  $ disp: num  160 160 108 258 360 ...</span></span><br><span class="line"></span><br><span class="line">tsk_mtcars <span class="operator">&lt;-</span> as_task_regr<span class="punctuation">(</span>mtcars_subset<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> id <span class="operator">=</span> <span class="string">&quot;cars&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>数据可以是任何表格格式，例如 <code>data.frame()</code>、 <code>data.table()</code> 或 <code>tibble()</code> 。 <code>target</code> 参数指定预测目标列。 <code>id</code> 参数是可选的，用于指定任务标识符，该标识符将用于绘图和摘要；如果省略，将使用数据的变量名作为 <code>id</code> 。</p>
<p><code>&lt;u&gt;</code>打印任务会提供一个摘要 <code>&lt;/u&gt;</code>，在本例中，我们可以看到任务有 32 个观测值和 3 列（32 x 3），其中 <code>mpg</code> 是目标变量，没有特殊属性（ <code>Properties: -</code> ），并且有 2 个特征以双精度浮点格式存储。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tsk_mtcars</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;TaskRegr:cars&gt; (32 x 3)</span></span><br><span class="line"><span class="comment"># * Target: mpg</span></span><br><span class="line"><span class="comment"># * Properties: -</span></span><br><span class="line"><span class="comment"># * Features (2):</span></span><br><span class="line"><span class="comment">#   - dbl (2): cyl, disp</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用 {mlr3viz} 包来绘制任务图，它提供了目标和特征值分布的图形化摘要：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mlr3viz<span class="punctuation">)</span></span><br><span class="line">autoplot<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;pairs&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115700564.png"></p>
<h2 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h2><p><code>Task</code>中存储了数据与原数据，可以用适当方法提取数据。</p>
<p>可以使用多个字段来检索任务的元数据。例如，可以使用 <code>$nrow</code> 和 <code>$ncol</code> 来获取维度信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">c</span><span class="punctuation">(</span>tsk_mtcars<span class="operator">$</span>nrow<span class="punctuation">,</span> tsk_mtcars<span class="operator">$</span>ncol<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 32 3</span></span><br></pre></td></tr></table></figure>

<p>特征列和目标列的名称分别存储在 <code>$feature_names</code> 和 <code>$target_names</code> 中：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">c</span><span class="punctuation">(</span>Features <span class="operator">=</span> tsk_mtcars<span class="operator">$</span>feature_names<span class="punctuation">,</span></span><br><span class="line">  Target <span class="operator">=</span> tsk_mtcars<span class="operator">$</span>target_names<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Features1&#x27;cyl &#x27;Features2&#x27;disp&#x27; Target&#x27;mpg&#x27;</span></span><br></pre></td></tr></table></figure>

<p>任务的列具有唯一的 <code>character</code> 值名称，行则由唯一的自然数标识，称为行 ID。它们可以通过 <code>$row_ids</code> 字段进行访问：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head<span class="punctuation">(</span>tsk_mtcars<span class="operator">$</span>row_ids<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 123456</span></span><br></pre></td></tr></table></figure>

<p>行 ID 在训练或预测时不会被用作特征，而是作为元数据，用于访问单个观测值。<code>&lt;u&gt;</code>请注意，行 ID 与行号不同。<code>&lt;/u&gt;</code>这一点通过下面的例子可以很好地说明：我们首先从随机数据创建一个回归任务，打印原始的行 ID（对应行号 1-5），然后筛选三行（稍后将回到这个方法），并打印新的行 ID，此时它们已不再与行号对应。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task <span class="operator">=</span> as_task_regr<span class="punctuation">(</span>data.frame<span class="punctuation">(</span>x <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  target <span class="operator">=</span> <span class="string">&quot;y&quot;</span><span class="punctuation">)</span></span><br><span class="line">task<span class="operator">$</span>row_ids</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">task<span class="operator">$</span>filter<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">task<span class="operator">$</span>row_ids</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 3 4</span></span><br></pre></td></tr></table></figure>

<p>这一设计使得任务和学习器能够在真实的数据库管理系统上透明地操作，其中主键需要唯一但不一定连续。</p>
<p><code>&lt;u&gt;</code>任务中包含的数据可以通过 <code>&lt;/u&gt;&lt;u&gt;``$data() &lt;/u&gt;``&lt;u&gt;</code>访问 <code>&lt;/u&gt;</code>，该方法返回一个 <code>data.table</code> 对象。<code>&lt;u&gt;</code>此方法具有可选的 <code>&lt;/u&gt;&lt;u&gt;``rows&lt;/u&gt;``&lt;u&gt;</code> 和 <code>&lt;/u&gt;&lt;u&gt;``cols&lt;/u&gt;``&lt;u&gt;</code> 参数 <code>&lt;/u&gt;</code>，用于指定要检索的数据子集。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># retrieve all data</span></span><br><span class="line">tsk_mtcars<span class="operator">$</span>data<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># retrieve data for rows with IDs 1, 5, and 10 and all feature columns</span></span><br><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">tsk_mtcars<span class="operator">$</span>data<span class="punctuation">(</span>rows <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">)</span><span class="punctuation">,</span> cols <span class="operator">=</span> tsk_mtcars<span class="operator">$</span>feature_names<span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cyl  disp</span></span><br><span class="line"><span class="comment">#    &lt;num&gt; &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:     6 160.0</span></span><br><span class="line"><span class="comment"># 2:     8 360.0</span></span><br><span class="line"><span class="comment"># 3:     6 167.6</span></span><br></pre></td></tr></table></figure>

<p>可以通过 <code>&lt;u&gt;</code>使用 <code>&lt;/u&gt;&lt;u&gt;``$row_ids&lt;/u&gt;``&lt;u&gt;</code> 字段提取与给定行号对应的行 I <code>&lt;/u&gt;</code>D，从而使用行号而非行 ID 进行操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select the 2nd row of the task by extracting the second row_id:</span></span><br><span class="line">tsk_mtcars<span class="operator">$</span>data<span class="punctuation">(</span>rows <span class="operator">=</span> tsk_mtcars<span class="operator">$</span>row_ids<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mpg   cyl  disp</span></span><br><span class="line"><span class="comment">#    &lt;num&gt; &lt;num&gt; &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:    21     6   160</span></span><br></pre></td></tr></table></figure>

<p>可以始终使用base R 方法从任务中提取摘要数据，例如，总结基础数据：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>as.data.table<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mpg             cyl             disp  </span></span><br><span class="line"><span class="comment">#  Min.   :10.40   Min.   :4.000   Min.   : 71.1  </span></span><br><span class="line"><span class="comment">#  1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8  </span></span><br><span class="line"><span class="comment">#  Median :19.20   Median :6.000   Median :196.3  </span></span><br><span class="line"><span class="comment">#  Mean   :20.09   Mean   :6.188   Mean   :230.7  </span></span><br><span class="line"><span class="comment">#  3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0  </span></span><br><span class="line"><span class="comment">#  Max.   :33.90   Max.   :8.000   Max.   :472.0</span></span><br></pre></td></tr></table></figure>

<h2 id="修改任务"><a href="#修改任务" class="headerlink" title="修改任务"></a>修改任务</h2><p>提供了一些方法用于操作修改任务。</p>
<p>通过 <code>&lt;u&gt;</code>特征（列）<code>&lt;/u&gt;</code>进行子集选择可以使用 <code>$select()</code> ，将所需的特征名称作为字符向量传递；而通过 <code>&lt;u&gt;</code>观测（行）<code>&lt;/u&gt;</code>进行子集选择则使用 <code> $filter()</code> ，将行 ID 作为数值向量传递。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tsk_mtcars_small <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span> <span class="comment"># initialize with the full task</span></span><br><span class="line">tsk_mtcars_small<span class="operator">$</span>select<span class="punctuation">(</span><span class="string">&quot;cyl&quot;</span><span class="punctuation">)</span> <span class="comment"># keep only one feature</span></span><br><span class="line">tsk_mtcars_small<span class="operator">$</span>filter<span class="punctuation">(</span><span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">)</span> <span class="comment"># keep only these rows</span></span><br><span class="line">tsk_mtcars_small<span class="operator">$</span>data<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mpg   cyl</span></span><br><span class="line"><span class="comment">#    &lt;num&gt; &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:  21.0     6</span></span><br><span class="line"><span class="comment"># 2:  22.8     4</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>&lt;u&gt;</code>不想修改原 <code>&lt;/u&gt;&lt;u&gt;``Task&lt;/u&gt;</code>，光赋值复制没有用，需要使用 <code>$clone()</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the wrong way</span></span><br><span class="line">tsk_mtcars <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_wrong <span class="operator">&lt;-</span> tsk_mtcars</span><br><span class="line">tsk_mtcars_wrong<span class="operator">$</span>filter<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># original data affected</span></span><br><span class="line">tsk_mtcars<span class="operator">$</span>head<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mpg    am  carb   cyl  disp  drat  gear    hp  qsec    vs    wt</span></span><br><span class="line"><span class="comment">#    &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:    21     1     4     6   160   3.9     4   110 16.46     0 2.620</span></span><br><span class="line"><span class="comment"># 2:    21     1     4     6   160   3.9     4   110 17.02     0 2.875</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the right way</span></span><br><span class="line">tsk_mtcars <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_right <span class="operator">&lt;-</span> tsk_mtcars<span class="operator">$</span>clone<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_right<span class="operator">$</span>filter<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># original data unaffected</span></span><br><span class="line">tsk_mtcars<span class="operator">$</span>head<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mpg    am  carb   cyl  disp  drat  gear    hp  qsec    vs    wt</span></span><br><span class="line"><span class="comment">#    &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:  21.0     1     4     6   160  3.90     4   110 16.46     0 2.620</span></span><br><span class="line"><span class="comment"># 2:  21.0     1     4     6   160  3.90     4   110 17.02     0 2.875</span></span><br><span class="line"><span class="comment"># 3:  22.8     1     1     4   108  3.85     4    93 18.61     1 2.320</span></span><br><span class="line"><span class="comment"># 4:  21.4     0     1     6   258  3.08     3   110 19.44     1 3.215</span></span><br><span class="line"><span class="comment"># 5:  18.7     0     2     8   360  3.15     3   175 17.02     0 3.440</span></span><br><span class="line"><span class="comment"># 6:  18.1     0     1     6   225  2.76     3   105 20.22     1 3.460</span></span><br></pre></td></tr></table></figure>

<p>要向 <code>Task</code>添加额外的行和列，可以分别使用 <code>rbind()</code>和 <code>cbind()</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tsk_mtcars_small<span class="operator">$</span>cbind<span class="punctuation">(</span> <span class="comment"># add another column</span></span><br><span class="line">  data.frame<span class="punctuation">(</span>disp <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">150</span><span class="punctuation">,</span> <span class="number">160</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_small<span class="operator">$</span>rbind<span class="punctuation">(</span> <span class="comment"># add another row</span></span><br><span class="line">  data.frame<span class="punctuation">(</span>mpg <span class="operator">=</span> <span class="number">23</span><span class="punctuation">,</span> cyl <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> disp <span class="operator">=</span> <span class="number">170</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_small<span class="operator">$</span>data<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mpg   cyl  disp</span></span><br><span class="line"><span class="comment">#    &lt;num&gt; &lt;num&gt; &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:  21.0     6   150</span></span><br><span class="line"><span class="comment"># 2:  22.8     4   160</span></span><br><span class="line"><span class="comment"># 3:  23.0     5   170</span></span><br></pre></td></tr></table></figure>

<h1 id="学习器（Learners）"><a href="#学习器（Learners）" class="headerlink" title="学习器（Learners）"></a>学习器（Learners）</h1><p>类 <code>Learner</code> 的对象为 R 中许多流行的机器学习算法提供了统一的接口。 <code>mlr_learners</code> 字典包含了 mlr3 中所有可用的学习器。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mlr_learners</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;DictionaryLearner&gt; with 51 stored values</span></span><br><span class="line"><span class="comment"># Keys: classif.cv_glmnet, classif.debug, classif.featureless,</span></span><br><span class="line"><span class="comment">#   classif.glmnet, classif.kknn, classif.lda, classif.log_reg,</span></span><br><span class="line"><span class="comment">#   classif.multinom, classif.naive_bayes, classif.nnet, classif.qda,</span></span><br><span class="line"><span class="comment">#   classif.ranger, classif.rpart, classif.svm, classif.xgboost,</span></span><br><span class="line"><span class="comment">#   clust.MBatchKMeans, clust.SimpleKMeans, clust.agnes, clust.ap,</span></span><br><span class="line"><span class="comment">#   clust.bico, clust.birch, clust.cmeans, clust.cobweb, clust.dbscan,</span></span><br><span class="line"><span class="comment">#   clust.dbscan_fpc, clust.diana, clust.em, clust.fanny,</span></span><br><span class="line"><span class="comment">#   clust.featureless, clust.ff, clust.hclust, clust.hdbscan,</span></span><br><span class="line"><span class="comment">#   clust.kkmeans, clust.kmeans, clust.mclust, clust.meanshift,</span></span><br><span class="line"><span class="comment">#   clust.optics, clust.pam, clust.xmeans, regr.cv_glmnet, regr.debug,</span></span><br><span class="line"><span class="comment">#   regr.featureless, regr.glmnet, regr.kknn, regr.km, regr.lm,</span></span><br><span class="line"><span class="comment">#   regr.nnet, regr.ranger, regr.rpart, regr.svm, regr.xgboost</span></span><br></pre></td></tr></table></figure>

<p>以树算法为例，我们使用 <code>lrn</code>函数访问学习器：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree</span></span><br><span class="line"><span class="comment"># * Model: -</span></span><br><span class="line"><span class="comment"># * Parameters: xval=0</span></span><br><span class="line"><span class="comment"># * Packages: mlr3, rpart</span></span><br><span class="line"><span class="comment"># * Predict Types:  [response]</span></span><br><span class="line"><span class="comment"># * Feature Types: logical, integer, numeric, factor, ordered</span></span><br><span class="line"><span class="comment"># * Properties: importance, missings, selected_features, weights</span></span><br></pre></td></tr></table></figure>

<p>所有 Learner 对象都包含以下元数据，可以在上面的输出中看到：</p>
<ul>
<li><code>$feature_types</code>: 学习器能够处理的特征类型。</li>
<li><code>$packages</code>: 使用该学习器需要安装的软件包。</li>
<li><code>$properties</code>: 学习器的属性。例如，<code>&quot;missings&quot;</code>属性表示模型能够处理缺失数据，<code>&quot;importance&quot;</code>表示它可以计算每个特征的相对重要性。</li>
<li><code>$predict_types</code>: 模型可以做出的预测类型。</li>
<li><code>$param_set</code>: 可用的超参数集合。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">)</span><span class="operator">$</span>param_set</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;ParamSet(10)&gt;</span></span><br><span class="line"><span class="comment">#                 id    class lower upper nlevels        default  value</span></span><br><span class="line"><span class="comment">#             &lt;char&gt;   &lt;char&gt; &lt;num&gt; &lt;num&gt;   &lt;num&gt;         &lt;list&gt; &lt;list&gt;</span></span><br><span class="line"><span class="comment">#  1:             cp ParamDbl     0     1     Inf           0.01 [NULL]</span></span><br><span class="line"><span class="comment">#  2:     keep_model ParamLgl    NA    NA       2          FALSE [NULL]</span></span><br><span class="line"><span class="comment">#  3:     maxcompete ParamInt     0   Inf     Inf              4 [NULL]</span></span><br><span class="line"><span class="comment">#  4:       maxdepth ParamInt     1    30      30             30 [NULL]</span></span><br><span class="line"><span class="comment">#  5:   maxsurrogate ParamInt     0   Inf     Inf              5 [NULL]</span></span><br><span class="line"><span class="comment">#  6:      minbucket ParamInt     1   Inf     Inf &lt;NoDefault[0]&gt; [NULL]</span></span><br><span class="line"><span class="comment">#  7:       minsplit ParamInt     1   Inf     Inf             20 [NULL]</span></span><br><span class="line"><span class="comment">#  8: surrogatestyle ParamInt     0     1       2              0 [NULL]</span></span><br><span class="line"><span class="comment">#  9:   usesurrogate ParamInt     0     2       3              2 [NULL]</span></span><br><span class="line"><span class="comment"># 10:           xval ParamInt     0   Inf     Inf             10      0</span></span><br></pre></td></tr></table></figure>

<p>为了运行一个机器学习实验，学习器需要经历两个阶段：</p>
<ol>
<li><strong>训练</strong>：将训练 <code>Task </code>传递给学习器的 <code>$train()</code> 函数，该函数训练并存储模型，即学习到的特征与目标之间的关系。</li>
<li><strong>预测</strong>：将新数据（可能是原始数据集的不同分区）传递给训练好的学习器的 <code>$predict()</code> 方法，以预测目标值。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115719054.png"></p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>在最简单的使用案例中，模型通过使用 <code>$train()</code> 方法将任务传递给学习器进行训练：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">tsk_mtcars <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建学习器</span></span><br><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>训练完成后，拟合模型存储在 <code>$model</code> 字段中，以便后续检查和预测：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看模型</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>model</span><br><span class="line"></span><br><span class="line"><span class="comment"># n= 32 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># node), split, n, deviance, yval</span></span><br><span class="line"><span class="comment">#       * denotes terminal node</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) root 32 1126.04700 20.09062  </span></span><br><span class="line"><span class="comment">#   2) cyl&gt;=5 21  198.47240 16.64762  </span></span><br><span class="line"><span class="comment">#     4) hp&gt;=192.5 7   28.82857 13.41429 *</span></span><br><span class="line"><span class="comment">#     5) hp&lt; 192.5 14   59.87214 18.26429 *</span></span><br><span class="line"><span class="comment">#   3) cyl&lt; 5 11  203.38550 26.66364 *</span></span><br></pre></td></tr></table></figure>

<p>我们看到回归树已经识别出任务中与目标（ <code>mpg</code> ）相关的预测特征，并利用这些特征对观测值进行划分。模型的文本表示形式取决于学习器的类型。</p>
<h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p>在评估模型预测质量时，可能需要对数据集进行分区，以获得对模型泛化误差的公平且无偏的估计这部分内容我们后面详细讨论，这里简单介绍一下。</p>
<p><code>partition()</code>函数可以创建索引集，将给定任务随机分成两个互不相交的集合：训练集（默认占总数据的 67%）和测试集（剩余 33%不属于训练集的数据）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">)</span></span><br><span class="line">splits</span><br><span class="line"></span><br><span class="line"><span class="comment"># $train</span></span><br><span class="line"><span class="comment"># 2345678913151618192021222324273031</span></span><br><span class="line"><span class="comment"># $test</span></span><br><span class="line"><span class="comment"># 110111214172526282932</span></span><br><span class="line"><span class="comment"># $validation</span></span><br></pre></td></tr></table></figure>

<p>在训练时，我们可以通过将行 ID 从 <code>partition</code> 传递给 <code>$train()</code> 的 <code>row_ids</code>参数来告诉模型仅使用训练数据：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> row_id <span class="operator">=</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以使用训练好的学习器对新数据进行预测。</p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>从训练好的模型进行预测非常简单，只需将你的数据作为 <code>Task</code> 传递给训练好的 <code>Learner</code> 的 <code>$predict()</code> 方法。</p>
<p>延续上一个示例，我们将调用训练好的学习器的 <code> $predict()</code> 方法，并再次使用 <code>row_ids</code> 参数，但这次传递的是测试集的 ID：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> row_id <span class="operator">=</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><code>$predict()</code> 方法返回一个继承自 <code>Prediction</code> 的对象，在本例中为 <code>PredictionRegr</code> ，因为这是一个回归任务。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prediction</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;PredictionRegr&gt; for 11 observations:</span></span><br><span class="line"><span class="comment">#  row_ids truth response</span></span><br><span class="line"><span class="comment">#        1  21.0 25.97778</span></span><br><span class="line"><span class="comment">#        4  21.4 15.12500</span></span><br><span class="line"><span class="comment">#        5  18.7 15.12500</span></span><br><span class="line"><span class="comment">#      ---   ---      ---</span></span><br><span class="line"><span class="comment">#       28  30.4 25.97778</span></span><br><span class="line"><span class="comment">#       30  19.7 25.97778</span></span><br><span class="line"><span class="comment">#       31  15.0 15.12500</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>row_ids</code> 列对应预测观测值的行 ID。</li>
<li><code>truth</code> 列包含真实数据（如果可用），对象从任务中提取，本例中为 <code>tsk_mtcars$truth(splits$test)</code> 。</li>
<li><code>response</code> 列包含模型预测的值。 <code>Prediction</code> 对象可以分别使用 <code>as.data.table()</code>或 <code>as.data.frame()</code> 轻松转换为 <code>data.table</code> 或 <code>data.frame</code> 。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">as.data.table<span class="punctuation">(</span>prediction<span class="punctuation">)</span> <span class="operator">%&gt;%</span> head<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># row_ids truth response</span></span><br><span class="line"><span class="comment">#      &lt;int&gt; &lt;num&gt;    &lt;num&gt;</span></span><br><span class="line"><span class="comment"># 1:       1  21.0 25.97778</span></span><br><span class="line"><span class="comment"># 2:       4  21.4 15.12500</span></span><br><span class="line"><span class="comment"># 3:       5  18.7 15.12500</span></span><br><span class="line"><span class="comment"># 4:       7  14.3 15.12500</span></span><br><span class="line"><span class="comment"># 5:       9  22.8 25.97778</span></span><br><span class="line"><span class="comment"># 6:      10  19.2 25.97778</span></span><br></pre></td></tr></table></figure>

<p>上述列中的所有数据都可以直接访问，例如，获取前两个预测响应：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>response<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [1] 25.97778 15.12500</span></span><br></pre></td></tr></table></figure>

<p>与绘制 <code>Task</code> 类似， {mlr3viz} 为 <code>Prediction</code> 对象提供了 <code>autoplot()</code> 方法。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mlr3viz<span class="punctuation">)</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line">autoplot<span class="punctuation">(</span>prediction<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115802226.png"></p>
<p>以回归任务为例，‎<code>autoplot(prediction)</code> 默认会画出预测值（横轴）与真实值（纵轴）的散点图。如果模型预测得好，点会大致分布在 y = x 的对角线上，说明预测值和真实值高度一致。点偏离对角线越远，说明误差越大。</p>
<p>如果想要直接传递 <code>data.frame</code> 类型的对象，则可以使用 <code>$predict_newdata()</code> 。请注意， <code>truth</code> 列的值均为 <code>NA</code> ，因为我们在生成的数据中没有包含目标列。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mtcars_new <span class="operator">&lt;-</span> data.table<span class="punctuation">(</span></span><br><span class="line">  cyl <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  disp <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> <span class="number">120</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  hp <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> <span class="number">150</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  drat <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">3.9</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  wt <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3.8</span><span class="punctuation">,</span> <span class="number">4.1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  qsec <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">18</span><span class="punctuation">,</span> <span class="number">19.5</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  vs <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  am <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  gear <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">6</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  carb <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict_newdata<span class="punctuation">(</span>mtcars_new<span class="punctuation">)</span></span><br><span class="line">prediction</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;PredictionRegr&gt; for 2 observations:</span></span><br><span class="line"><span class="comment">#  row_ids truth response</span></span><br><span class="line"><span class="comment">#        1    NA 25.97778</span></span><br><span class="line"><span class="comment">#        2    NA 25.97778</span></span><br></pre></td></tr></table></figure>

<h2 id="更改预测类型"><a href="#更改预测类型" class="headerlink" title="更改预测类型"></a>更改预测类型</h2><p>虽然预测单个数值量是回归中最常见的预测类型，但它并非唯一的预测类型。一些回归模型还能预测标准误差。</p>
<p>为此，在训练前必须将 <code>LearnerRegr</code> 的 <code>$predict_type</code> 字段从默认的 <code>$response</code>更改为 <code>&quot;se&quot;</code> 。</p>
<p>上文使用的 <code>&quot;rpart&quot;</code> 学习器不支持预测标准误差，因此在下面的示例中，我们将使用线性回归模型（ <code>lrn(&quot;regr.lm&quot;</code>) ）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mlr3learners<span class="punctuation">)</span></span><br><span class="line">lrn_lm <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.lm&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;se&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_lm<span class="operator">$</span>train<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line">lrn_lm<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;PredictionRegr&gt; for 11 observations:</span></span><br><span class="line"><span class="comment">#  row_ids truth  response       se</span></span><br><span class="line"><span class="comment">#        1  21.0 18.385337 2.846863</span></span><br><span class="line"><span class="comment">#        4  21.4 19.282261 1.838898</span></span><br><span class="line"><span class="comment">#        5  18.7 16.995092 1.682557</span></span><br><span class="line"><span class="comment">#      ---   ---       ---      ---</span></span><br><span class="line"><span class="comment">#       28  30.4 15.246709 4.767612</span></span><br><span class="line"><span class="comment">#       30  19.7  6.590408 6.315215</span></span><br><span class="line"><span class="comment">#       31  15.0 -3.600168 8.810161</span></span><br></pre></td></tr></table></figure>

<p>现在输出中包含了所需的 <code>se</code> 列。</p>
<h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p><code>Learner</code> 封装了机器学习算法及其超参数，这些超参数会影响算法的运行方式，并且可以由用户设置。超参数可能影响模型的训练方式或预测方式，而如何设置超参数可能需要专业知识。我们先学习手动设置参数。</p>
<h3 id="Paradox-与参数集"><a href="#Paradox-与参数集" class="headerlink" title="Paradox 与参数集"></a>Paradox 与参数集</h3><p>我们将继续以回归树学习器为例。要访问决策树中的超参数，我们使用 <code>$param_set</code> ：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart<span class="operator">$</span>param_set</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;ParamSet(10)&gt;</span></span><br><span class="line"><span class="comment">#                 id    class lower upper nlevels        default  value</span></span><br><span class="line"><span class="comment">#             &lt;char&gt;   &lt;char&gt; &lt;num&gt; &lt;num&gt;   &lt;num&gt;         &lt;list&gt; &lt;list&gt;</span></span><br><span class="line"><span class="comment">#  1:             cp ParamDbl     0     1     Inf           0.01 [NULL]</span></span><br><span class="line"><span class="comment">#  2:     keep_model ParamLgl    NA    NA       2          FALSE [NULL]</span></span><br><span class="line"><span class="comment">#  3:     maxcompete ParamInt     0   Inf     Inf              4 [NULL]</span></span><br><span class="line"><span class="comment">#  4:       maxdepth ParamInt     1    30      30             30 [NULL]</span></span><br><span class="line"><span class="comment">#  5:   maxsurrogate ParamInt     0   Inf     Inf              5 [NULL]</span></span><br><span class="line"><span class="comment">#  6:      minbucket ParamInt     1   Inf     Inf &lt;NoDefault[0]&gt; [NULL]</span></span><br><span class="line"><span class="comment">#  7:       minsplit ParamInt     1   Inf     Inf             20 [NULL]</span></span><br><span class="line"><span class="comment">#  8: surrogatestyle ParamInt     0     1       2              0 [NULL]</span></span><br><span class="line"><span class="comment">#  9:   usesurrogate ParamInt     0     2       3              2 [NULL]</span></span><br><span class="line"><span class="comment"># 10:           xval ParamInt     0   Inf     Inf             10      0</span></span><br></pre></td></tr></table></figure>

<p>上述输出是一个由 {paradox}包提供的 <code>ParamSet</code> 对象。</p>
<p>这些对象提供了关于超参数的信息，包括其名称( <code>id</code> )、数据类型( <code>class</code> )、超参数值在技术上的有效范围( <code>lower</code> 、 <code>upper</code> )、如果数据类型为分类变量时可能的级别数量( <code>nlevels</code> )、来自底层包的默认值( <code>default</code> )，以及最终设定的值( <code>value</code> )。</p>
<p>第二列引用了 {paradox} 中定义的类，这些类决定了参数的类型及其可能取值。</p>
<p>下表列出了可能的超参数类型，所有这些类型都继承自 {Domain} 。</p>
<table>
<thead>
<tr>
<th>Hyperparameter Class  超参数类</th>
<th>Hyperparameter Type  超参数类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;ParamDbl&quot;</code></td>
<td>Real-valued (numeric)</td>
</tr>
<tr>
<td><code>&quot;ParamInt&quot;</code></td>
<td>Integer</td>
</tr>
<tr>
<td><code>&quot;ParamFct&quot;</code></td>
<td>Categorical (factor)</td>
</tr>
<tr>
<td><code>&quot;ParamLgl&quot;</code></td>
<td>Logical &#x2F; Boolean</td>
</tr>
<tr>
<td><code>&quot;ParamUty&quot;</code></td>
<td>Untyped</td>
</tr>
</tbody></table>
<p>在我们的决策树示例中，我们可以从 <code>ParamSet</code> 输出推断出：</p>
<ul>
<li><code>cp</code>  必须是一个 <code>&quot;double&quot;</code>（ <code>ParamDbl</code> ），取值范围在 0 （<code> lower</code> ）到 1 （ <code>upper </code>）之间，默认值为 0.01（ <code>default </code>）。</li>
<li><code>keep_model</code>必须是一个“逻辑”值（ P <code>aramLgl</code> ），取值为 <code>TRUE</code> 或 <code>FALSE</code> ，默认值为 <code>FALSE</code></li>
<li><code>xval</code> 必须是一个“整数”（ <code>ParamInt</code> ），取值范围在 0 和 Inf 之间，默认值为 10 ，当前设定值为 0 。</li>
</ul>
<h3 id="获取与设置超参数值"><a href="#获取与设置超参数值" class="headerlink" title="获取与设置超参数值"></a>获取与设置超参数值</h3><p>回到我们的决策树，假设我们想要生成一个深度为 1 的树，也就是所谓的“决策桩”，其中数据仅被分割一次形成两个终端节点。从参数集输出中，我们知道 <code>maxdepth</code> 参数的默认值为 30 ，并且它接受整数值。</p>
<p>我们可以通过几种不同的方式来更改这个超参数。<code>&lt;u&gt;</code>最简单的方法是在构建学习器时，将超参数名称和新值传递给 <code>&lt;/u&gt;&lt;u&gt;``lrn()&lt;/u&gt;``&lt;u&gt;</code>：<code>&lt;/u&gt;</code></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">,</span> maxdepth <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过使用 <code>$param_setvalues$value</code> 来 <code>&lt;u&gt;</code>获取非默认超参数（即已设置的参数）的列表 <code>&lt;/u&gt;</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart<span class="operator">$</span>param_set<span class="operator">$</span>values</span><br><span class="line"></span><br><span class="line"><span class="comment"># $maxdepth</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># $xval</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>现在我们可以看到 <code>maxdepth = 1</code>，学习到的回归树反映了这一点：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">$</span>model</span><br><span class="line"></span><br><span class="line"><span class="comment"># n= 32 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># node), split, n, deviance, yval</span></span><br><span class="line"><span class="comment">#       * denotes terminal node</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) root 32 1126.0470 20.09062  </span></span><br><span class="line"><span class="comment">#   2) cyl&gt;=5 21  198.4724 16.64762 *</span></span><br><span class="line"><span class="comment">#   3) cyl&lt; 5 11  203.3855 26.66364 *</span></span><br></pre></td></tr></table></figure>

<p><code>$values</code> 字段仅返回一组超参数的 <code>list</code> ，因此 <code>&lt;u&gt;</code>另一种更新超参数的方法是通过更新列表中的元素 <code>&lt;/u&gt;</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart<span class="operator">$</span>param_set<span class="operator">$</span>values<span class="operator">$</span>maxdepth <span class="operator">&lt;-</span> 2</span><br><span class="line">lrn_rpart<span class="operator">$</span>param_set<span class="operator">$</span>values</span><br><span class="line"></span><br><span class="line"><span class="comment"># $maxdepth</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># $xval</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># now with depth 2</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">$</span>model</span><br><span class="line"></span><br><span class="line"><span class="comment"># n= 32 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># node), split, n, deviance, yval</span></span><br><span class="line"><span class="comment">#       * denotes terminal node</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) root 32 1126.04700 20.09062  </span></span><br><span class="line"><span class="comment">#   2) cyl&gt;=5 21  198.47240 16.64762  </span></span><br><span class="line"><span class="comment">#     4) hp&gt;=192.5 7   28.82857 13.41429 *</span></span><br><span class="line"><span class="comment">#     5) hp&lt; 192.5 14   59.87214 18.26429 *</span></span><br><span class="line"><span class="comment">#   3) cyl&lt; 5 11  203.38550 26.66364 *</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;u&gt;</code>要一次性设置多个值，建议在构建过程中设置这些值或使用 <code>&lt;/u&gt;&lt;u&gt;``$set_values()&lt;/u&gt;</code> ，它会用相应的值更新给定的超参数（参数名称）。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart <span class="operator">=</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">,</span> maxdepth <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> xval <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>param_set<span class="operator">$</span>values</span><br><span class="line"></span><br><span class="line"><span class="comment"># $maxdepth</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># $xval</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># or with set_values</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>param_set<span class="operator">$</span>set_values<span class="punctuation">(</span>xval <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> cp <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>param_set<span class="operator">$</span>values</span><br><span class="line"></span><br><span class="line"><span class="comment"># $cp</span></span><br><span class="line"><span class="comment"># 0.5</span></span><br><span class="line"><span class="comment"># $maxdepth</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># $xval</span></span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 <code>lrn_rpart$param_set$values</code> 返回一个 <code>list </code>，一些用户可能会尝试通过向 <code>$values</code> 传递一个新的 <code>list</code> 来设置超参数——这样做虽然可行，<code>&lt;u&gt;</code>但不建议采用 <code>&lt;/u&gt;</code>。因为传递 <code> list</code> 会清除所有未包含在列表中的现有超参数值。例如：</p>
</blockquote>
<p>无论选择哪种方法，所有方法都包含安全检查，以确保新值在允许的参数范围内：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">,</span> cp <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> maxdepth <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Error in self$assert(xs, sanitize = TRUE): Assertion on &#x27;xs&#x27; failed: cp: Element 1 is not &lt;= 1.</span></span><br><span class="line"><span class="comment"># Traceback:</span></span><br></pre></td></tr></table></figure>

<h3 id="超参数依赖关系"><a href="#超参数依赖关系" class="headerlink" title="超参数依赖关系"></a>超参数依赖关系</h3><p>更复杂的超参数空间可能包含依赖关系，即设置一个超参数取决于另一个超参数的值，这在调参中非常重要。</p>
<p>一个例子是支持向量机（ <code>lrn(&quot;regr.svm&quot;)</code> ）。字段 <code>$deps</code> 返回一个 <code>data.table</code> ，其中列出了 <code>Learner</code> 中的超参数依赖关系。例如，我们可以看到 <code>cost</code> （ <code>id</code> 列）参数依赖于 <code>type</code> （ <code>on</code> 列）参数。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.svm&quot;</span><span class="punctuation">)</span><span class="operator">$</span>param_set<span class="operator">$</span>deps <span class="operator">%&gt;%</span> print<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># id     on                  cond</span></span><br><span class="line"><span class="comment">#     &lt;char&gt; &lt;char&gt;                &lt;list&gt;</span></span><br><span class="line"><span class="comment"># 1:   coef0 kernel &lt;Condition:CondAnyOf&gt;</span></span><br><span class="line"><span class="comment"># 2:    cost   type &lt;Condition:CondAnyOf&gt;</span></span><br><span class="line"><span class="comment"># 3:  degree kernel &lt;Condition:CondEqual&gt;</span></span><br><span class="line"><span class="comment"># 4: epsilon   type &lt;Condition:CondEqual&gt;</span></span><br><span class="line"><span class="comment"># 5:   gamma kernel &lt;Condition:CondAnyOf&gt;</span></span><br><span class="line"><span class="comment"># 6:      nu   type &lt;Condition:CondEqual&gt;</span></span><br></pre></td></tr></table></figure>

<p>这告诉我们，参数 <code>cost</code> 仅在参数 <code>type</code> 为 <code>&quot;eps-regression&quot;</code> 或 <code>&quot;nu-regression&quot;</code> 之一时才应设置，而 <code>degree</code> 仅在 <code>kernel</code> 等于 <code>&quot;polynomial&quot;</code> 时才应设置。</p>
<p>如果设置了依赖的超参数但未满足其条件， <code>Learner</code> 将会报错：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># error as kernel is not polynomial</span></span><br><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.svm&quot;</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">&quot;linear&quot;</span><span class="punctuation">,</span> degree <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Error in self$assert(xs, sanitize = TRUE): Assertion on &#x27;xs&#x27; failed: degree: can only be set if the following condition is met &#x27;kernel == polynomial&#x27;. Instead the current parameter value is: kernel == linear.</span></span><br><span class="line"><span class="comment"># Traceback:</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># works because kernel is polynomial</span></span><br><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.svm&quot;</span><span class="punctuation">,</span> kernel <span class="operator">=</span> <span class="string">&quot;polynomial&quot;</span><span class="punctuation">,</span> degree <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;LearnerRegrSVM:regr.svm&gt;: Support Vector Machine</span></span><br><span class="line"><span class="comment"># * Model: -</span></span><br><span class="line"><span class="comment"># * Parameters: degree=1, kernel=polynomial</span></span><br><span class="line"><span class="comment"># * Packages: mlr3, mlr3learners, e1071</span></span><br><span class="line"><span class="comment"># * Predict Types:  [response]</span></span><br><span class="line"><span class="comment"># * Feature Types: logical, integer, numeric</span></span><br><span class="line"><span class="comment"># * Properties: -</span></span><br></pre></td></tr></table></figure>

<h2 id="基线学习器"><a href="#基线学习器" class="headerlink" title="基线学习器"></a>基线学习器</h2><p>在继续讨论学习器评估之前，我们将重点介绍一类重要的学习器。这些是极其简单或“弱”的学习器，被称为<strong>基线（Baseline）</strong> 。在机器学习中，基线学习器的主要作用是为模型评估和比较提供“下限”或“起点”。这些学习器通常不利用输入特征的信息，而是采用最简单的预测策略。对于回归问题，我们实现了基线 <code>lrn(&quot;regr.featureless&quot;)</code> ，它总是预测新值为训练数据中目标的均值（或者如果 <code>robust</code> 超参数设置为 <code>TRUE</code> ，则为中位数）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">df <span class="operator">&lt;-</span> as_task_regr<span class="punctuation">(</span></span><br><span class="line">  data.frame<span class="punctuation">(</span>x <span class="operator">=</span> runif<span class="punctuation">(</span><span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">,</span> y <span class="operator">=</span> rnorm<span class="punctuation">(</span><span class="number">1000</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  target <span class="operator">=</span> <span class="string">&quot;y&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line">lrn<span class="punctuation">(</span><span class="string">&quot;regr.featureless&quot;</span><span class="punctuation">)</span><span class="operator">$</span>train<span class="punctuation">(</span>df<span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">995</span><span class="punctuation">)</span><span class="operator">$</span>predict<span class="punctuation">(</span>df<span class="punctuation">,</span> <span class="number">996</span><span class="operator">:</span><span class="number">1000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>测试所有新模型时对照基线是一种好方法，同时在包含多个其他模型的实验中也应纳入基线学习器。一般来说，未能超越基线表现的模型属于“差”模型，但反过来，优于基线的模型也不一定就是“好”模型。</p>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>或许应用机器学习工作流程中最重要的步骤是评估模型性能。没有这一步，我们将无法得知训练出的模型预测是否非常准确、比随机猜测更差，还是介于两者之间。我们将继续使用决策树示例来确定预测质量的“好坏”，我们重新运行一遍上述代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="度量指标"><a href="#度量指标" class="headerlink" title="度量指标"></a>度量指标</h2><p>预测质量通过比较监督学习任务中的预测结果与真实数据来评估。类似于 <code>Task</code> 和 <code>Learner</code> ， <code>mlr3</code> 中可用的度量标准存储在一个名为 <code>mlr_measures</code> 的字典中，可以通过 <code>msr()</code> 访问：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">msr<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;DictionaryMeasure&gt; with 75 stored values</span></span><br><span class="line"><span class="comment"># Keys: aic, bic, ci, ci.con_z, ci.cor_t, ci.holdout, ci.ncv, ci.wald_cv,</span></span><br><span class="line"><span class="comment">#   classif.acc, classif.auc, classif.bacc, classif.bbrier, classif.ce,</span></span><br><span class="line"><span class="comment">#   classif.costs, classif.dor, classif.fbeta, classif.fdr, classif.fn,</span></span><br><span class="line"><span class="comment">#   classif.fnr, classif.fomr, classif.fp, classif.fpr, classif.logloss,</span></span><br><span class="line"><span class="comment">#   classif.mauc_au1p, classif.mauc_au1u, classif.mauc_aunp,</span></span><br><span class="line"><span class="comment">#   classif.mauc_aunu, classif.mauc_mu, classif.mbrier, classif.mcc,</span></span><br><span class="line"><span class="comment">#   classif.npv, classif.ppv, classif.prauc, classif.precision,</span></span><br><span class="line"><span class="comment">#   classif.recall, classif.sensitivity, classif.specificity, classif.tn,</span></span><br><span class="line"><span class="comment">#   classif.tnr, classif.tp, classif.tpr, clust.ch, clust.dunn,</span></span><br><span class="line"><span class="comment">#   clust.silhouette, clust.wss, debug_classif, internal_valid_score,</span></span><br><span class="line"><span class="comment">#   oob_error, regr.bias, regr.ktau, regr.mae, regr.mape, regr.maxae,</span></span><br><span class="line"><span class="comment">#   regr.medae, regr.medse, regr.mse, regr.msle, regr.pbias,</span></span><br><span class="line"><span class="comment">#   regr.pinball, regr.rae, regr.rmse, regr.rmsle, regr.rrse, regr.rse,</span></span><br><span class="line"><span class="comment">#   regr.rsq, regr.sae, regr.smape, regr.srho, regr.sse,</span></span><br><span class="line"><span class="comment">#   selected_features, sim.jaccard, sim.phi, time_both, time_predict,</span></span><br><span class="line"><span class="comment">#   time_train</span></span><br></pre></td></tr></table></figure>

<p>也可以转化为 <code>data.table</code>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as.data.table<span class="punctuation">(</span>msr<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> head<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115819861.png"></p>
<p>在 {mlr3} 中实现的所有度量主要由三个组成部分定义：</p>
<ol>
<li>定义度量的函数；</li>
<li>较低值还是较高值被视为“好”；</li>
<li>度量可能取值的范围。</li>
</ol>
<p>除了这些定义要素外，在选择和使用 <code>Measure</code> 时还需考虑其他重要元数据，包括度量是否具有任何特殊属性（例如需要训练数据）、度量可以评估的预测类型，以及度量是否有任何“控制参数”。所有这些信息都封装在 <code>Measure</code> 对象中。举例来说，让我们考虑平均绝对误差（MAE）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">measure <span class="operator">&lt;-</span> msr<span class="punctuation">(</span><span class="string">&quot;regr.mae&quot;</span><span class="punctuation">)</span></span><br><span class="line">measure</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;MeasureRegrSimple:regr.mae&gt;: Mean Absolute Error</span></span><br><span class="line"><span class="comment"># * Packages: mlr3, mlr3measures</span></span><br><span class="line"><span class="comment"># * Range: [0, Inf]</span></span><br><span class="line"><span class="comment"># * Minimize: TRUE</span></span><br><span class="line"><span class="comment"># * Average: macro</span></span><br><span class="line"><span class="comment"># * Parameters: list()</span></span><br><span class="line"><span class="comment"># * Properties: -</span></span><br><span class="line"><span class="comment"># * Predict type: response</span></span><br></pre></td></tr></table></figure>

<p>该指标比较真实值与预测值之间的绝对差异（“误差”）：$f(y,\hat y)&#x3D;|y−\hat y|$。数值越低被认为越好（ <code>Minimize: TRUE</code> ），这很直观，因为我们希望真实值 y 与预测值 y^ 在数值上完全相同（或尽可能接近）。可以看出，学习器可能取值的范围是从 0 到$\infin$（ <code>Range: [0, Inf]</code> ），它没有特殊属性（ <code>Properties: -</code> ），评估回归模型的 <code>response</code> 类型预测（ <code>Predict type: response</code> ），并且没有控制参数（ <code>Parameters: list()</code> ）。</p>
<h2 id="预测得分"><a href="#预测得分" class="headerlink" title="预测得分"></a>预测得分</h2><p>通常，监督学习的度量方法会比较 <code>&lt;u&gt;</code>预测值与真实值 <code>&lt;/u&gt;</code>之间的差异。正如我们已经看到的， <code>Prediction</code> 对象通过存储预测结果和真实结果，简化了将这些量整合在一起的过程。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prediction</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;PredictionRegr&gt; for 11 observations:</span></span><br><span class="line"><span class="comment">#  row_ids truth response</span></span><br><span class="line"><span class="comment">#        2  21.0 16.73333</span></span><br><span class="line"><span class="comment">#        4  21.4 16.73333</span></span><br><span class="line"><span class="comment">#        6  18.1 16.73333</span></span><br><span class="line"><span class="comment">#      ---   ---      ---</span></span><br><span class="line"><span class="comment">#       22  15.5 16.73333</span></span><br><span class="line"><span class="comment">#       29  15.8 16.73333</span></span><br><span class="line"><span class="comment">#       31  15.0 16.73333</span></span><br></pre></td></tr></table></figure>

<p>要计算模型性能，我们只需调用 <code>Prediction</code> 对象的 <code>$score()</code> 方法，并传入一个参数即我们想要计算的度量指标：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measure<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># regr.mae: 3.13030303030303</span></span><br></pre></td></tr></table></figure>

<p>请注意，所有任务类型都有默认的度量标准，如果省略了 <code>$score()</code> 参数，则会使用这些默认度量。对于回归任务，默认度量是均方误差（ <code>msr(&quot;regr.mse&quot;)</code> ），即$f(y, \hat y) &#x3D; (y - \hat y)^2$。</p>
<p>可以通过向 <code>$score()</code> 传递多个度量指标来同时计算多个指标。例如，下面我们计算均方误差（ <code>&quot;regr.mse&quot;</code> ）和平均绝对误差（ <code>&quot;regr.mae&quot;</code> ）的性能表现——注意我们使用 <code>msrs()</code> 一次性加载多个度量指标。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">measures <span class="operator">&lt;-</span> msrs<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;regr.mse&quot;</span><span class="punctuation">,</span> <span class="string">&quot;regr.mae&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># regr.mse13.9318181818182 regr.mae3.13030303030303</span></span><br></pre></td></tr></table></figure>

<h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><p>{mlr3} 还提供了一些不量化模型预测质量的度量，而是提供关于模型的“元”信息。这些包括：</p>
<ul>
<li><p><code>msr(&quot;time_train&quot;)</code> – 训练模型所需的时间。</p>
</li>
<li><p><code>msr(&quot;time_predict&quot;)</code> – 模型进行预测所花费的时间。</p>
</li>
<li><p><code>msr(&quot;time_both&quot;)</code> – 训练模型并随后进行预测所需的总时间。</p>
<p><code>msr(&quot;selected_features&quot;)</code> – 模型选择的特征数量，仅当模型具有 <code>selected_features</code>属性时可用。</p>
</li>
</ul>
<p>例如，我们可以对我们的决策树进行评分，看看训练模型和进行预测花费了多少秒：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">measures <span class="operator">&lt;-</span> msrs<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;time_train&quot;</span><span class="punctuation">,</span> <span class="string">&quot;time_predict&quot;</span><span class="punctuation">,</span> <span class="string">&quot;time_both&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">,</span> learner <span class="operator">=</span> lrn_rpart<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># time_train0.00200000000040745 time_predict0.000999999996565748 time_both0.0029999999969732</span></span><br></pre></td></tr></table></figure>

<p>请注意这些测量方法的几个关键属性：</p>
<ol>
<li><p><code>time_both</code> 只是 <code>time_train</code> 和 <code>time_predict</code>的总和。</p>
</li>
<li><p>我们必须将 <code>learner = lrn_rpart</code> 传递给 <code>$score()</code> ，因为这些度量具有 <code>requires_learner</code> 属性：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msr<span class="punctuation">(</span><span class="string">&quot;time_train&quot;</span><span class="punctuation">)</span><span class="operator">$</span>properties</span><br></pre></td></tr></table></figure></li>
<li><p>这些可以在模型训练和预测后使用，因为每当调用 <code>train()</code>和 <code>predict()</code> 时，我们会自动存储模型运行时间，因此上述测量等同于：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">c</span><span class="punctuation">(</span>lrn_rpart<span class="operator">$</span>timings<span class="punctuation">,</span> both <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>lrn_rpart<span class="operator">$</span>timings<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>selected_features</code> 指标计算了拟合模型中使用了多少个特征：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">msr_sf  <span class="operator">&lt;-</span> msr<span class="punctuation">(</span><span class="string">&quot;selected_features&quot;</span><span class="punctuation">)</span></span><br><span class="line">msr_sf</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;MeasureSelectedFeatures:selected_features&gt;: Absolute or Relative Frequency of Selected Features</span></span><br><span class="line"><span class="comment"># * Packages: mlr3</span></span><br><span class="line"><span class="comment"># * Range: [0, Inf]</span></span><br><span class="line"><span class="comment"># * Minimize: TRUE</span></span><br><span class="line"><span class="comment"># * Average: macro</span></span><br><span class="line"><span class="comment"># * Parameters: normalize=FALSE</span></span><br><span class="line"><span class="comment"># * Properties: requires_task, requires_learner, requires_model,</span></span><br><span class="line"><span class="comment">#   requires_no_prediction</span></span><br><span class="line"><span class="comment"># * Predict type: NA</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到这个度量包含控制参数（ <code>Parameters: normalize=FALSE</code> ），它们控制着度量的计算方式。与超参数一样，这些参数可以通过 <code>$param_set</code> 来访问：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msr_sf <span class="operator">&lt;-</span> msr<span class="punctuation">(</span><span class="string">&quot;selected_features&quot;</span><span class="punctuation">)</span></span><br><span class="line">msr_sf<span class="operator">$</span>param_set</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;ParamSet(1)&gt;</span></span><br><span class="line"><span class="comment">#           id    class lower upper nlevels        default  value</span></span><br><span class="line"><span class="comment">#       &lt;char&gt;   &lt;char&gt; &lt;num&gt; &lt;num&gt;   &lt;num&gt;         &lt;list&gt; &lt;list&gt;</span></span><br><span class="line"><span class="comment"># 1: normalize ParamLgl    NA    NA       2 &lt;NoDefault[0]&gt;  FALSE</span></span><br></pre></td></tr></table></figure>

<p><code>normalize</code> 超参数指定返回的选定特征数量是否应按特征总数进行归一化，这在比较具有不同特征数量的任务时非常有用。我们将以与上述学习器完全相同的方式更改此参数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msr_sf<span class="operator">$</span>param_set<span class="operator">$</span>values<span class="operator">$</span>normalize <span class="operator">&lt;-</span> <span class="literal">TRUE</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>msr_sf<span class="punctuation">,</span> task <span class="operator">=</span> tsk_mtcars<span class="punctuation">,</span> learner <span class="operator">=</span> lrn_rpart<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># selected_features: 0.1</span></span><br></pre></td></tr></table></figure>

<p>请注意，我们传递了任务和学习器，因为该度量具有 <code>requires_task</code> 和 <code>requires_learner</code> 属性。</p>
<h1 id="测试回归"><a href="#测试回归" class="headerlink" title="测试回归"></a>测试回归</h1><p>有了上述的知识，我们先来尝试一下用{mlr3}构建回归模型。</p>
<p>加载R包并设置种子：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mlr3<span class="punctuation">)</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">123</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>研究范式，先确定任务，随后划分数据集，确定学习器，训练模型并最终预测</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">tsk_mtcars <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义弱学习器</span></span><br><span class="line">lrn_featureless <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.featureless&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义树学习器</span></span><br><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;regr.rpart&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义评估指标为MSE与MAE</span></span><br><span class="line">measures <span class="operator">&lt;-</span> msrs<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;regr.mse&quot;</span><span class="punctuation">,</span> <span class="string">&quot;regr.mae&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lrn_featureless<span class="operator">$</span>train<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">pred_featureless <span class="operator">&lt;-</span> lrn_featureless<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line">pred_rpart <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_mtcars<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>接下来分别评估两个模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pred_featureless<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># regr.mse 48.7093114821686</span></span><br><span class="line"><span class="comment"># regr.mae 5.50692640692641</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pred_rpart<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># regr.mse 20.8335241301908</span></span><br><span class="line"><span class="comment"># regr.mae 3.72020202020202</span></span><br></pre></td></tr></table></figure>

<p>可以判断树模型由于基线模型。</p>
<h1 id="分类（Classification）"><a href="#分类（Classification）" class="headerlink" title="分类（Classification）"></a>分类（Classification）</h1><p><strong>分类问题</strong>是指模型预测一个离散的、分类的目标，而不是连续的、数值量。例如，根据企鹅的物理特征预测其物种就是一个分类问题，因为物种集合是明确有限的。 {mlr3} 确保所有任务的接口尽可能相似（如非完全相同），因此我们不会重复前一节的内容，而只关注使分类成为独特机器学习问题的差异。</p>
<h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><p>因为结构高度统一，我们可以便捷的写出一个类似回归的试验：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>mlr3<span class="punctuation">)</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">349</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">tsk_penguins <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;penguins&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_penguins<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义弱学习器</span></span><br><span class="line">lrn_featureless <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.featureless&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义树学习器</span></span><br><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.rpart&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义评估指标为准确率</span></span><br><span class="line">measures <span class="operator">&lt;-</span> msrs<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;classif.acc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lrn_featureless<span class="operator">$</span>train<span class="punctuation">(</span>tsk_penguins<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_penguins<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">pred_featureless <span class="operator">&lt;-</span> lrn_featureless<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_penguins<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line">pred_rpart <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_penguins<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>评估一下模型性能：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pred_featureless<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.acc: 0.456140350877193</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pred_rpart<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.acc: 0.93859649122807</span></span><br></pre></td></tr></table></figure>

<p>看得出来决策树性能比弱学习器强很多。</p>
<h2 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h2><p>分类任务（继承自 <code>TaskClassif</code> 的对象）与回归任务非常相似，只不过 <code>&lt;u&gt;</code>目标变量的类型为因子型 <code>&lt;/u&gt;</code>，且 <code>&lt;u&gt;</code>观测值只能属于有限数量的可能类别&#x2F;分类 <code>&lt;/u&gt;</code>。</p>
<p>您可以通过筛选 <code>mlr_tasks</code> 字典来查看 {mlr3} 中预定义的分类任务：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as.data.table<span class="punctuation">(</span>mlr_tasks<span class="punctuation">)</span><span class="punctuation">[</span>task_type <span class="operator">==</span> <span class="string">&quot;classif&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115838360.png"></p>
<p>你可以使用 <code>as_task_classif</code> 创建自己的任务：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">as_task_classif<span class="punctuation">(</span>palmerpenguins<span class="operator">::</span>penguins<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;species&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;TaskClassif:palmerpenguins::penguins&gt; (344 x 8)</span></span><br><span class="line"><span class="comment"># * Target: species</span></span><br><span class="line"><span class="comment"># * Properties: multiclass</span></span><br><span class="line"><span class="comment"># * Features (7):</span></span><br><span class="line"><span class="comment">#   - int (3): body_mass_g, flipper_length_mm, year</span></span><br><span class="line"><span class="comment">#   - dbl (2): bill_depth_mm, bill_length_mm</span></span><br><span class="line"><span class="comment">#   - fct (2): island, sex</span></span><br></pre></td></tr></table></figure>

<p>在 {mlr3} 中支持两种类型的分类任务：二分类（binary classification），即结果可以是两个类别之一；以及多分类（multiclass classification），其中结果可以是三个或更多类别之一。</p>
<p><code>sonar</code> 任务是一个二分类问题的示例，因为目标变量只能取两个不同的值，在 <code>mlr3</code> 术语中它具有“twoclass”属性：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tsk_sonar <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;sonar&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_sonar</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;TaskClassif:sonar&gt; (208 x 61): Sonar: Mines vs. Rocks</span></span><br><span class="line"><span class="comment"># * Target: Class</span></span><br><span class="line"><span class="comment"># * Properties: twoclass</span></span><br><span class="line"><span class="comment"># * Features (60):</span></span><br><span class="line"><span class="comment">#   - dbl (60): V1, V10, V11, V12, V13, V14, V15, V16, V17, V18, V19, V2,</span></span><br><span class="line"><span class="comment">#     V20, V21, V22, V23, V24, V25, V26, V27, V28, V29, V3, V30, V31,</span></span><br><span class="line"><span class="comment">#     V32, V33, V34, V35, V36, V37, V38, V39, V4, V40, V41, V42, V43,</span></span><br><span class="line"><span class="comment">#     V44, V45, V46, V47, V48, V49, V5, V50, V51, V52, V53, V54, V55,</span></span><br><span class="line"><span class="comment">#     V56, V57, V58, V59, V6, V60, V7, V8, V9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tsk_sonar<span class="operator">$</span>class_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;M&#x27;&#x27;R&#x27;</span></span><br></pre></td></tr></table></figure>

<p>两者对比， <code>tsk(&quot;penguins&quot;)</code> 是一个多类别问题，因为企鹅的种类超过两种；它具有“多类别”属性：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tsk_penguins <span class="operator">=</span> tsk<span class="punctuation">(</span><span class="string">&quot;penguins&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_penguins<span class="operator">$</span>properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;multiclass&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tsk_penguins<span class="operator">$</span>class_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;Adelie&#x27;&#x27;Chinstrap&#x27;&#x27;Gentoo&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;u&gt;</code>这些任务之间的另一个区别在于，二元分类任务有一个额外的字段 <code>&lt;/u&gt;&lt;u&gt;``$positive&lt;/u&gt;``&lt;u&gt;</code> ，用于定义“正类”。<code>&lt;/u&gt;</code>在二元分类中，由于只有两种可能的类别类型，按照惯例，其中一类被称为“正类”，另一类被称为“负类”。具体哪一类为正类可以任意指定，不过通常会将更“重要”（且通常数量较少）的类别设为正类。您可以在构建过程中或之后设置正类。如果未指定正类，则 {mlr3} 会假定 <code>target</code> 列中的第一个级别为正类，这可能导致误导性的结果。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span>Sonar<span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;mlbench&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">tsk_classif <span class="operator">&lt;-</span> as_task_classif<span class="punctuation">(</span>Sonar<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;Class&quot;</span><span class="punctuation">,</span> positive <span class="operator">=</span> <span class="string">&quot;R&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看positive类</span></span><br><span class="line">tsk_classif<span class="operator">$</span>positive</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;R&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务后修改属性</span></span><br><span class="line">tsk_classif<span class="operator">$</span>positive <span class="operator">&lt;-</span> <span class="string">&quot;M&quot;</span></span><br><span class="line">tsk_classif<span class="operator">$</span>positive</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;M&#x27;</span></span><br></pre></td></tr></table></figure>

<p>虽然正类和负类的选择是任意的，但它们对于确保模型结果和性能指标按预期解释至关重要，这一点和阈值处理相关。</p>
<p>最后，可以使用 <code>autoplot.TaskClassif</code> 进行绘图，下面我们绘制目标列与特征的比较图。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">autoplot<span class="punctuation">(</span>tsk<span class="punctuation">(</span><span class="string">&quot;penguins&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;duo&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>strip.text.y <span class="operator">=</span> element_text<span class="punctuation">(</span>angle <span class="operator">=</span> <span class="operator">-</span><span class="number">45</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">8</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115856582.png"></p>
<h2 id="分类学习器与分类度量"><a href="#分类学习器与分类度量" class="headerlink" title="分类学习器与分类度量"></a>分类学习器与分类度量</h2><p>分类学习器继承自 <code>LearnerClassif</code> ，其接口与回归学习器几乎相同。然而，<code>&lt;u&gt;</code>一个关键区别在于分类中的预测结果可能是 <code>&lt;/u&gt;&lt;u&gt;``&quot;response&quot;&lt;/u&gt;``&lt;u&gt;</code> （预测观测值的类别，例如我们例子中的企鹅种类，有时称为“硬标签”），或者是 <code>&lt;/u&gt;&lt;u&gt;``&quot;prob&quot;&lt;/u&gt;``&lt;u&gt;</code> （预测观测值属于每个类别的概率向量，也称为“后验概率”）<code>&lt;/u&gt;</code>。在分类中，后者可能更有用，因为它提供了关于预测置信度的信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.rpart&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_penguins<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> rn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_penguins<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line">prediction</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;PredictionClassif&gt; for 114 observations:</span></span><br><span class="line"><span class="comment">#  row_ids     truth  response prob.Adelie prob.Chinstrap prob.Gentoo</span></span><br><span class="line"><span class="comment">#        1    Adelie    Adelie  0.97029703     0.02970297   0.0000000</span></span><br><span class="line"><span class="comment">#        2    Adelie    Adelie  0.97029703     0.02970297   0.0000000</span></span><br><span class="line"><span class="comment">#        3    Adelie    Adelie  0.97029703     0.02970297   0.0000000</span></span><br><span class="line"><span class="comment">#      ---       ---       ---         ---            ---         ---</span></span><br><span class="line"><span class="comment">#      338 Chinstrap Chinstrap  0.04255319     0.93617021   0.0212766</span></span><br><span class="line"><span class="comment">#      339 Chinstrap Chinstrap  0.04255319     0.93617021   0.0212766</span></span><br><span class="line"><span class="comment">#      342 Chinstrap Chinstrap  0.04255319     0.93617021   0.0212766</span></span><br></pre></td></tr></table></figure>

<p>请注意，预测结果包含了所有三个类别的预测概率，以及 <code>response</code> （默认情况下是预测概率最高的类别）。</p>
<p>此外，分类度量（属于 <code>MeasureClassif</code> 类）的接口与回归度量完全相同。使用上的关键区别在于，你需要确保所选度量评估的是你感兴趣的预测类型。要评估 <code>&quot;response&quot;</code> 预测，你需要带有 <code>predict_type = &quot;response&quot;</code> 的度量；若要评估概率预测，则需要 <code>predict_type = &quot;prob&quot;</code> 。查找这些度量的最简单方法是通过过滤 <code>mlr_measures</code> 字典：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">as.data.table<span class="punctuation">(</span>msr<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">[</span></span><br><span class="line">  task_type <span class="operator">==</span> <span class="string">&quot;classif&quot;</span> <span class="operator">&amp;</span></span><br><span class="line">    predict_type <span class="operator">==</span> <span class="string">&quot;prob&quot;</span> <span class="operator">&amp;</span></span><br><span class="line">    <span class="operator">!</span>sapply<span class="punctuation">(</span>task_properties<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="string">&quot;twoclass&quot;</span> <span class="operator">%in%</span> x<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115913284.png"></p>
<p>我们还过滤掉了所有具有 <code>&quot;twoclass&quot;</code> 属性的测量值，因为这会影响我们的 <code>&quot;multiclass&quot;</code> 任务。为此我们需要使用 <code>sapply</code> ， <code>task_properties</code> 列是一个列表列。我们可以通过提供多个测量值来同时评估概率预测和响应预测的质量：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">measures <span class="operator">&lt;-</span> msrs<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;classif.mbrier&quot;</span><span class="punctuation">,</span> <span class="string">&quot;classif.logloss&quot;</span><span class="punctuation">,</span> <span class="string">&quot;classif.acc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.mbrier 0.102899613594403</span></span><br><span class="line"><span class="comment"># classif.logloss 0.754807810861767</span></span><br><span class="line"><span class="comment"># classif.acc 0.93859649122807</span></span><br></pre></td></tr></table></figure>

<p>准确度衡量评估的是 <code>&quot;response&quot;</code> 预测，而 Brier 分数（ <code>&quot;classif.mbrier&quot;</code> ，预测概率与真实值之间的平方差）和对数损失（ <code>&quot;classif.logloss&quot;</code> ，真实类别预测概率的负对数）评估的是概率预测。</p>
<p>如果没有传递度量标准到 <code>$score()</code> ，则默认使用分类错误率（ <code>msr(&quot;classif.ce&quot;)</code> ），即错误分类的数量除以预测总数，即 1− <code>msr(&quot;classif.acc&quot;)</code> 。</p>
<h2 id="PredictionClassif-、混淆矩阵与阈值设定"><a href="#PredictionClassif-、混淆矩阵与阈值设定" class="headerlink" title="PredictionClassif 、混淆矩阵与阈值设定"></a>PredictionClassif 、混淆矩阵与阈值设定</h2><p><code>PredictionClassif</code> 对象与其回归类比有两个重要区别。首先，增加了字段 <code>$confusion</code> ，其次增加了方法 <code>$set_threshold()</code> 。</p>
<h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>混淆矩阵是一种流行的方法，通过观察模型在特定类别中（错误）分类观测值的能力，以更详细的方式展示分类（响应）预测的质量。对于二分类和多分类问题，混淆矩阵存储在 <code>PredictionClassif</code> 对象的 <code>$confusion</code> 字段中。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>confusion</span><br><span class="line"></span><br><span class="line"><span class="comment"># truth</span></span><br><span class="line"><span class="comment"># response    Adelie Chinstrap Gentoo</span></span><br><span class="line"><span class="comment">#   Adelie        48         2      0</span></span><br><span class="line"><span class="comment">#   Chinstrap      4        14      1</span></span><br><span class="line"><span class="comment">#   Gentoo         0         0     45</span></span><br></pre></td></tr></table></figure>

<p>混淆矩阵的行代表预测类别，列代表真实类别。所有非对角线上的条目都是被错误分类的观测值，而对角线上的条目则是被正确分类的。在本例中，分类器对所有企鹅的分类效果都相当不错，但我们可能会发现它仅能很好地分类阿德利企鹅，却经常混淆帽带企鹅和巴布亚企鹅。</p>
<p>可以使用 <code>autoplot.PredictionClassif()</code> 来可视化预测的类别标签。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoplot<span class="punctuation">(</span>prediction<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115931052.png"></p>
<p>在二分类情况下，左上角条目对应真正例（true positives），右上角为假正例（false positives），左下角为假反例（false negatives），右下角为真反例（true negatives）。以 <code>tsk_sonar</code> 为例，其中 M 作为正类：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_sonar<span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span></span><br><span class="line">  train<span class="punctuation">(</span>tsk_sonar<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span><span class="operator">$</span></span><br><span class="line">  predict<span class="punctuation">(</span>tsk_sonar<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span><span class="operator">$</span></span><br><span class="line">  confusion</span><br><span class="line"></span><br><span class="line"><span class="comment"># truth</span></span><br><span class="line"><span class="comment"># response  M  R</span></span><br><span class="line"><span class="comment">#        M 16 13</span></span><br><span class="line"><span class="comment">#        R 13 27</span></span><br></pre></td></tr></table></figure>

<h3 id="设定阈值"><a href="#设定阈值" class="headerlink" title="设定阈值"></a>设定阈值</h3><p>我们将讨论的与回归相比最后一个重大区别是阈值处理。之前我们了解到，默认的 <code>response</code> 预测类型是具有最高预测概率的类别。对于预测概率为 <code>k</code> 的类别 $p_1, \cdots, p_k$ ，这相当于说 <code>response</code> $&#x3D; \argmax {p_1,…,p_k}$ 。如果最大概率不唯一，即多个类别被预测为具有相同的最高概率，则从这些类别中随机选择响应。在二分类中，这意味着如果预测类别大于 50%，则选择正类，否则选择负类。</p>
<p><code>&lt;u&gt;</code>这个 50%的值被称为 <code>&lt;/u&gt;</code><strong><code>&lt;u&gt;</code>阈值 <code>&lt;/u&gt;</code></strong> <code>&lt;u&gt;</code>，在存在类别不平衡（即某一类别在数据集中过多或过少）、不同类别具有不同成本，或者仅仅偏好“过度”预测某一类别时，调整该阈值会很有用。<code>&lt;/u&gt;</code>举个例子，假设 <code>tsk(&quot;german_credit&quot;)</code> 中有 700 名客户信用良好，300 名信用不良。此时，如果我们总是预测客户信用良好，就能轻松构建一个准确率约为“70%”的模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task_credit <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;german_credit&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_featureless <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.featureless&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br><span class="line">split <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>task_credit<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lrn_featureless<span class="operator">$</span>train<span class="punctuation">(</span>task_credit<span class="punctuation">,</span> split<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_featureless<span class="operator">$</span>predict<span class="punctuation">(</span>task_credit<span class="punctuation">,</span> split<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.acc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.acc: 0.693939393939394</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoplot<span class="punctuation">(</span>prediction<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519115950141.png"></p>
<p>虽然这个模型表面上看起来性能良好，但实际上它只是忽略了所有“不良”客户——这在金融案例中可能会引发严重问题，同样在医疗保健任务及其他误报成本高于漏报的场景中也是如此。</p>
<p>阈值处理允许以不同的概率阈值选择类别，因此，我们不再在 P(good) &lt; 50%时预测客户信用不良，而是可能在 P(good) &lt; 70%时预测信用不良——注意我们如何用正类（在本任务中为 <code>&#39;good&#39;</code>）来表达这一点。让我们在实践中看看这一点：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>set_threshold<span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.acc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.acc: 0.693939393939394</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.rpart&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>task_credit<span class="punctuation">,</span> split<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>task_credit<span class="punctuation">,</span> split<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.acc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.acc: 0.757575757575758</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>confusion</span><br><span class="line"></span><br><span class="line"><span class="comment">#         truth</span></span><br><span class="line"><span class="comment"># response good bad</span></span><br><span class="line"><span class="comment">#     good  203  54</span></span><br><span class="line"><span class="comment">#     bad    26  47</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>set_threshold<span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>msr<span class="punctuation">(</span><span class="string">&quot;classif.acc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.acc: 0.757575757575758</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>confusion</span><br><span class="line"></span><br><span class="line"><span class="comment"># truth</span></span><br><span class="line"><span class="comment"># response good bad</span></span><br><span class="line"><span class="comment">#     good  202  53</span></span><br><span class="line"><span class="comment">#     bad    27  48</span></span><br></pre></td></tr></table></figure>

<p>虽然我们的模型整体表现“较差”，即准确率较低，但它仍然是一个“更好”的模型，因为它更准确地捕捉了类别之间的关系。</p>
<p>在二分类设置中， <code>$set_threshold()</code> 仅需要一个数值参数，该参数对应于正类的阈值——因此必须确保在任务中正确设置了正类。</p>
<p><code>&lt;u&gt;</code>在多类别分类中，阈值处理的工作原理是首先为每个 <code>&lt;/u&gt;&lt;u&gt;``n&lt;/u&gt;``&lt;u&gt;</code> 类别分配一个阈值，将每个类别的预测概率除以这些阈值以得到 <code>&lt;/u&gt;&lt;u&gt;``n&lt;/u&gt;``&lt;u&gt;</code> 比率，然后选择比率最高的类别。<code>&lt;/u&gt;</code>例如，假设我们正在预测一个新观测值属于类别 A、B、C 还是 D，并且我们已经预测了 P(A=0.2),P(B=0.4),P(C=0.1),P(D=0.3) 。我们将假设所有类别的阈值相同且为 <code>1</code> ：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义概率向量</span></span><br><span class="line">probs <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="number">0.1</span><span class="punctuation">,</span> <span class="number">0.3</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 定义阈值向量，并命名</span></span><br><span class="line">thresholds <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>A <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> B <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> C <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> D <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 逐元素相除</span></span><br><span class="line">probs <span class="operator">/</span> thresholds</span><br><span class="line"></span><br><span class="line"><span class="comment"># A0.2B0.4C0.1D0.3</span></span><br></pre></td></tr></table></figure>

<p>因此，我们会预测观察结果属于类别 B，因为这是最高的比率。然而，我们可以调整阈值，使得 D 的阈值最低且最有可能被预测，A 的阈值最高，而 B 和 C 的阈值相同：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thresholds <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>A <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> B <span class="operator">=</span> <span class="number">0.25</span><span class="punctuation">,</span> C <span class="operator">=</span> <span class="number">0.25</span><span class="punctuation">,</span> D <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span></span><br><span class="line">probs <span class="operator">/</span> thresholds</span><br><span class="line"></span><br><span class="line"><span class="comment"># A0.4B1.6C0.4D3</span></span><br></pre></td></tr></table></figure>

<p>现在我们的观测将被预测为属于类别 D。</p>
<p>在 {mlr3} 中，这是通过向 <code>$set_threshold()</code> 传递一个命名列表来实现的。如下所示，使用 <code>tsk(&quot;zoo&quot;)</code> 进行演示。在更改阈值之前，某些类别从未被预测到，而另一些类别的预测频率高于实际出现频率。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>patchwork<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">tsk_zoo <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;zoo&quot;</span><span class="punctuation">)</span></span><br><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_zoo<span class="punctuation">)</span></span><br><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.rpart&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br><span class="line">lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_zoo<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>predict<span class="punctuation">(</span>tsk_zoo<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line">before <span class="operator">&lt;-</span> autoplot<span class="punctuation">(</span>prediction<span class="punctuation">)</span> <span class="operator">+</span> ggtitle<span class="punctuation">(</span><span class="string">&quot;Default thresholds&quot;</span><span class="punctuation">)</span></span><br><span class="line">new_thresh <span class="operator">&lt;-</span> proportions<span class="punctuation">(</span>table<span class="punctuation">(</span>tsk_zoo<span class="operator">$</span>truth<span class="punctuation">(</span>splits<span class="operator">$</span>test<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">new_thresh</span><br><span class="line"></span><br><span class="line"><span class="comment"># mammal          bird       reptile          fish     amphibian </span></span><br><span class="line"><span class="comment">#    0.39393939    0.18181818    0.06060606    0.15151515    0.03030303 </span></span><br><span class="line"><span class="comment">#        insect mollusc.et.al </span></span><br><span class="line"><span class="comment">#    0.06060606    0.12121212</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>set_threshold<span class="punctuation">(</span>new_thresh<span class="punctuation">)</span></span><br><span class="line">after <span class="operator">&lt;-</span> utoplot<span class="punctuation">(</span>prediction<span class="punctuation">)</span> <span class="operator">+</span> ggtitle<span class="punctuation">(</span><span class="string">&quot;Inverse weighting thresholds&quot;</span><span class="punctuation">)</span></span><br><span class="line">before <span class="operator">+</span> after <span class="operator">+</span> plot_layout<span class="punctuation">(</span>guides <span class="operator">=</span> <span class="string">&quot;collect&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120006073.png"></p>
<p>再次看到，经过阈值处理后，模型能更好地代表所有类别。在本例中，我们将新阈值设为训练集中每个类别的比例。这种方法被称为<strong>逆加权</strong>，因为我们在选择具有最高比率的标签之前，将预测概率除以这些类别比例。</p>
<h1 id="任务列角色（Task-Column-Roles）"><a href="#任务列角色（Task-Column-Roles）" class="headerlink" title="任务列角色（Task Column Roles）"></a>任务列角色（Task Column Roles）</h1><p>在介绍了回归和分类之后，我们将简要回顾任务，特别是列角色，它们用于进一步定制任务。列角色被 <code>Task</code> 对象用来定义重要的元数据，这些元数据可以被学习器和其他对象用来与任务交互。顾名思义，它们为数据中的列分配特定的角色，我们已经看到了一些实际应用中的目标和特征。共有七种列角色：</p>
<ol>
<li><code>&quot;feature&quot;</code>: 用于预测的特征。</li>
<li><code>&quot;target&quot;</code> : 要预测的目标变量。</li>
<li><code>&quot;name&quot;</code>: 行名&#x2F;观测标签，例如对于 <code>mtcars</code> ，这是 <code>&quot;model&quot;</code> 列。</li>
<li><code>&quot;order&quot;</code>：用于对 <code>$data()</code> 返回的数据进行排序的变量；必须能够使用 <code>order()</code> 进行排序。</li>
<li><code>&quot;group&quot;</code>: 在重采样过程中用于保持观测数据分组的变量。</li>
<li><code>&quot;stratum&quot;</code>: 重采样过程中用于分层的变量。</li>
<li><code>&quot;weight&quot;</code>: 观测权重。仅允许一个数值列承担此角色。</li>
</ol>
<p><code>&quot;feature&quot;</code>和 <code>&quot;target&quot;</code>是每个任务都必须要有的角色。<code>stratum</code> 和 <code>group</code> 列角色后面讨论。我们不会详细讨论 <code>name</code> ，它主要用于绘图，并且几乎总是底层数据的 <code>rownames()</code> 。</p>
<p>因此，目前我们只关注 <code>order</code> 和 <code>weight</code> 。</p>
<p>列角色通过 <code>$set_col_roles()</code> 进行更新。当我们设置 <code>&quot;order&quot;</code> 列角色时，数据会根据该列（或这些列）进行排序。在以下示例中，我们设置 <code>&quot;order&quot;</code> 列角色，然后通过包含 <code>ordered = TRUE</code> 来按该列对数据进行排序：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>mtcars<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">,</span> <span class="punctuation">]</span><span class="punctuation">,</span> idx <span class="operator">=</span> <span class="number">2</span><span class="operator">:</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_order <span class="operator">&lt;-</span> as_task_regr<span class="punctuation">(</span>df<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;mpg&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">tsk_mtcars_order<span class="operator">$</span>data<span class="punctuation">(</span>order <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120021579.png"></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用idx列排序</span></span><br><span class="line">tsk_mtcars_order<span class="operator">$</span>set_col_roles<span class="punctuation">(</span><span class="string">&quot;idx&quot;</span><span class="punctuation">,</span> role <span class="operator">=</span> <span class="string">&quot;order&quot;</span><span class="punctuation">)</span></span><br><span class="line">tsk_mtcars_order<span class="operator">$</span>data<span class="punctuation">(</span>order <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120035078.png"></p>
<p>在这个例子中，我们可以看到，通过将 <code>&quot;idx&quot;</code> 设置为具有 <code>&quot;order&quot;</code> 列角色，当我们运行 <code>$data()</code> 时，它不再被用作特征，而是根据其值对观测值进行排序。这些元数据不会传递给学习器。</p>
<p><code>&lt;u&gt;weights``&lt;/u&gt;&lt;u&gt;</code> 列的角色用于对数据点进行不同的加权。我们这样做的原因之一是在类别严重不平衡的分类任务中，对少数类别赋予更高的权重可能会提升模型对该类别的预测性能 <code>&lt;/u&gt;</code>。例如在 <code>breast_cancer</code> 数据集中，良性肿瘤的实例多于恶性肿瘤，因此如果我们想更好地预测恶性肿瘤，可以对该类别的数据进行加权：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记得设置种子</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">357</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">cancer_unweighted <span class="operator">&lt;-</span> tsk<span class="punctuation">(</span><span class="string">&quot;breast_cancer&quot;</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>cancer_unweighted<span class="operator">$</span>data<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">$</span><span class="built_in">class</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># malignant239 benign444</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置权重</span></span><br><span class="line">df <span class="operator">&lt;-</span> cancer_unweighted<span class="operator">$</span>data<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span></span><br><span class="line">    weight <span class="operator">=</span> ifelse<span class="punctuation">(</span><span class="built_in">class</span> <span class="operator">==</span> <span class="string">&quot;malignant&quot;</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务</span></span><br><span class="line">cancer_weighted <span class="operator">&lt;-</span> as_task_classif<span class="punctuation">(</span>df<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;class&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置权重列角色</span></span><br><span class="line">cancer_weighted<span class="operator">$</span>set_col_roles<span class="punctuation">(</span><span class="string">&quot;weight&quot;</span><span class="punctuation">,</span> role <span class="operator">=</span> <span class="string">&quot;weight&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集</span></span><br><span class="line">split <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>cancer_unweighted<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置学习器</span></span><br><span class="line">lrn_rf <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.ranger&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>先看下未加权数据集上的效果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未加权数据集</span></span><br><span class="line">lrn_rf<span class="operator">$</span>train<span class="punctuation">(</span>cancer_unweighted<span class="punctuation">,</span> split<span class="operator">$</span>train<span class="punctuation">)</span><span class="operator">$</span></span><br><span class="line">  predict<span class="punctuation">(</span>cancer_unweighted<span class="punctuation">,</span> split<span class="operator">$</span>test<span class="punctuation">)</span><span class="operator">$</span>score<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.ce: 0.04</span></span><br></pre></td></tr></table></figure>

<p>再看一下加权数据集上的效果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrn_rf<span class="operator">$</span>train<span class="punctuation">(</span>cancer_weighted<span class="punctuation">,</span> split<span class="operator">$</span>train<span class="punctuation">)</span><span class="operator">$</span></span><br><span class="line">  predict<span class="punctuation">(</span>cancer_weighted<span class="punctuation">,</span> split<span class="operator">$</span>test<span class="punctuation">)</span><span class="operator">$</span>score<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.ce: 0.0311111111111111</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，加权提高了模型的整体性能。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>掌握以下类与方法，就算是mlr3入门了！</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Constructor&#x2F;Function  构造函数&#x2F;函数</th>
<th>Fields&#x2F;Methods</th>
</tr>
</thead>
<tbody><tr>
<td><code>Task</code></td>
<td><code>tsk()</code>&#x2F;<code>tsks()</code>&#x2F;<code>as_task_X</code></td>
<td><code>$filter()</code>; <code>$select()</code>; <code>$data()</code></td>
</tr>
<tr>
<td><code>Learner</code></td>
<td><code>lrn()</code>&#x2F;<code>lrns()</code></td>
<td><code>$train()</code>; <code>$predict()</code>; <code>$predict_newdata()</code>; <code>$model()</code></td>
</tr>
<tr>
<td><code>Prediction</code></td>
<td><code>some_learner$predict()</code></td>
<td><code>$score()</code>; <code>$set_threshold()</code>; <code>$confusion</code></td>
</tr>
<tr>
<td><code>Measure</code></td>
<td><code>msr()</code>&#x2F;<code>msrs()</code></td>
<td></td>
</tr>
</tbody></table>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h2><blockquote>
<p>Train a classification model with the <code>classif.rpart</code> learner on the “Pima Indians Diabetes” dataset. Do this without using <code>tsk(&quot;pima&quot;)</code>, and instead by constructing a task from the dataset in the mlbench-package: <code>data(PimaIndiansDiabetes2, package = &quot;mlbench&quot;)</code>. Make sure to define the <code>pos</code> outcome as positive class. Train the model on a random 80% subset of the given data and evaluate its performance with the classification error measure on the remaining data. (Note that the data set has <code>NAs</code> in its features. You can either rely on <code>rpart</code>‘s capability to handle them internally (’surrogate splits’) or remove them from the initial <code>data.frame</code> by using <code>na.omit</code>.</p>
<p>使用 <code> classif.rpart</code> 学习器在“Pima Indians Diabetes”数据集上训练一个分类模型。不使用 <code>tsk(&quot;pima&quot;)</code> ，而是通过从 {mlbench} 包中的数据集构建任务： <code>data(PimaIndiansDiabetes2, package = &quot;mlbench&quot;) </code>。确保将 <code>pos</code> 结果定义为正类。在给定数据的随机 80%子集上训练模型，并在剩余数据上使用分类错误度量评估其性能。（注意数据集的特征中存在 <code>NA</code> 值。您可以依赖 <code>rpart</code> 内部处理它们的能力（’替代分割’），或者通过使用 <code>na.omit</code> 从初始 <code>data.frame</code> 中移除它们。）</p>
</blockquote>
<p>先查看一下数据集：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data<span class="punctuation">(</span>PimaIndiansDiabetes2<span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;mlbench&quot;</span><span class="punctuation">)</span></span><br><span class="line">df <span class="operator">&lt;-</span> PimaIndiansDiabetes2</span><br><span class="line">head<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120049409.png"></p>
<p>我们观察到有缺失值，但是有没有缺失值对决策树模型影响不大，因此我们直接建模：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务，pos为正类</span></span><br><span class="line">tsk_classif <span class="operator">&lt;-</span> as_task_classif<span class="punctuation">(</span>df<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;diabetes&quot;</span><span class="punctuation">,</span> positive <span class="operator">=</span> <span class="string">&quot;pos&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集，80%训练集，20%测试集</span></span><br><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_classif<span class="punctuation">,</span> ratio <span class="operator">=</span> <span class="number">0.8</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建学习器</span></span><br><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.rpart&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型并预测</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_classif<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span><span class="operator">$</span></span><br><span class="line">  predict<span class="punctuation">(</span>tsk_classif<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>使用错误率评价性能：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用错误率评价性能</span></span><br><span class="line">measure <span class="operator">&lt;-</span> msr<span class="punctuation">(</span><span class="string">&quot;classif.ce&quot;</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measure<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.ce: 0.207792207792208</span></span><br></pre></td></tr></table></figure>

<p>我们测试一下删掉缺失值再建模：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_no_na <span class="operator">&lt;-</span> df <span class="operator">%&gt;%</span> na.omit<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>df_no_na<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120101340.png"></p>
<p>拟合模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建任务，pos为正类</span></span><br><span class="line">tsk_classif <span class="operator">&lt;-</span> as_task_classif<span class="punctuation">(</span>df_no_na<span class="punctuation">,</span> target <span class="operator">=</span> <span class="string">&quot;diabetes&quot;</span><span class="punctuation">,</span> positive <span class="operator">=</span> <span class="string">&quot;pos&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集，80%训练集，20%测试集</span></span><br><span class="line">splits <span class="operator">&lt;-</span> partition<span class="punctuation">(</span>tsk_classif<span class="punctuation">,</span> ratio <span class="operator">=</span> <span class="number">0.8</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建学习器</span></span><br><span class="line">lrn_rpart <span class="operator">&lt;-</span> lrn<span class="punctuation">(</span><span class="string">&quot;classif.rpart&quot;</span><span class="punctuation">,</span> predict_type <span class="operator">=</span> <span class="string">&quot;prob&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型并预测</span></span><br><span class="line">prediction <span class="operator">&lt;-</span> lrn_rpart<span class="operator">$</span>train<span class="punctuation">(</span>tsk_classif<span class="punctuation">,</span> splits<span class="operator">$</span>train<span class="punctuation">)</span><span class="operator">$</span></span><br><span class="line">  predict<span class="punctuation">(</span>tsk_classif<span class="punctuation">,</span> splits<span class="operator">$</span>test<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用错误率评价性能</span></span><br><span class="line">measure <span class="operator">&lt;-</span> msr<span class="punctuation">(</span><span class="string">&quot;classif.ce&quot;</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measure<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.ce: 0.17948717948718</span></span><br></pre></td></tr></table></figure>

<p>性能稍强，但需注意其实不是同一数据，需谨慎对比解释。</p>
<h2 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h2><blockquote>
<p>Calculate the true positive, false positive, true negative, and false negative rates of the predictions made by the model in Exercise 1. Try to solve this in two ways: (a) Using mlr3measures-predefined measure objects, and (b) without using mlr3 tools by directly working on the ground truth and prediction vectors. Compare the results.</p>
<p>计算模型在练习 1 中所做预测的真阳性率、假阳性率、真阴性率和假阴性率。尝试用两种方式解决这个问题：(a) 使用 {mlr3measures} 预定义的度量对象；(b) 不使用 {mlr3} 工具，直接基于真实值和预测向量进行计算。比较结果。</p>
</blockquote>
<p>先使用{mlr3}提供的工具：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用mlr3verse预测TPR， FPR，TNR，FNR</span></span><br><span class="line">measures <span class="operator">&lt;-</span> msrs<span class="punctuation">(</span></span><br><span class="line">  <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;classif.tpr&quot;</span><span class="punctuation">,</span> <span class="string">&quot;classif.fpr&quot;</span><span class="punctuation">,</span> <span class="string">&quot;classif.tnr&quot;</span><span class="punctuation">,</span> <span class="string">&quot;classif.fnr&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classif.tpr 0.666666666666667</span></span><br><span class="line"><span class="comment"># classif.fpr 0.12280701754386</span></span><br><span class="line"><span class="comment"># classif.tnr 0.87719298245614</span></span><br><span class="line"><span class="comment"># classif.fnr 0.333333333333333</span></span><br></pre></td></tr></table></figure>

<p>接下来不使用{mlr3}，使用{tidyverse}工具实现，先提取真实值与预测值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df_truth_predict <span class="operator">&lt;-</span> tibble<span class="punctuation">(</span></span><br><span class="line">  truth <span class="operator">=</span> prediction<span class="operator">$</span>truth<span class="punctuation">,</span></span><br><span class="line">  response <span class="operator">=</span> prediction<span class="operator">$</span>response</span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>df_truth_predict<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120115043.png"></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">df_truth_predict <span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span></span><br><span class="line">    <span class="comment"># TP，真阳性，真实值为阳，预测值也为阳</span></span><br><span class="line">    TP <span class="operator">=</span> ifelse<span class="punctuation">(</span>truth <span class="operator">==</span> <span class="string">&quot;pos&quot;</span> <span class="operator">&amp;</span> response <span class="operator">==</span> <span class="string">&quot;pos&quot;</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># TN，真阴性，真实值为阴，预测值也为阴</span></span><br><span class="line">    TN <span class="operator">=</span> ifelse<span class="punctuation">(</span>truth <span class="operator">==</span> <span class="string">&quot;neg&quot;</span> <span class="operator">&amp;</span> response <span class="operator">==</span> <span class="string">&quot;neg&quot;</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># FP，假阳性，真实值为阴，预测值为阳</span></span><br><span class="line">    FP <span class="operator">=</span> ifelse<span class="punctuation">(</span>truth <span class="operator">==</span> <span class="string">&quot;neg&quot;</span> <span class="operator">&amp;</span> response <span class="operator">==</span> <span class="string">&quot;pos&quot;</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># FN，假阴性，真实值为阳，预测值为阴</span></span><br><span class="line">    FN <span class="operator">=</span> ifelse<span class="punctuation">(</span>truth <span class="operator">==</span> <span class="string">&quot;pos&quot;</span> <span class="operator">&amp;</span> response <span class="operator">==</span> <span class="string">&quot;neg&quot;</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># 逻辑检测列，检验总和是否为1</span></span><br><span class="line">    check <span class="operator">=</span> TP <span class="operator">+</span> TN <span class="operator">+</span> FP <span class="operator">+</span> FN</span><br><span class="line">  <span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  summarise<span class="punctuation">(</span></span><br><span class="line">    <span class="comment"># TPR = TP / (TP + FN)</span></span><br><span class="line">    TPR <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>TP<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>TP<span class="punctuation">)</span> <span class="operator">+</span> <span class="built_in">sum</span><span class="punctuation">(</span>FN<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># FPR = FP / (FP + TN)</span></span><br><span class="line">    FPR <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>FP<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>FP<span class="punctuation">)</span> <span class="operator">+</span> <span class="built_in">sum</span><span class="punctuation">(</span>TN<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># TNR = TN / (TN + FP)</span></span><br><span class="line">    TNR <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>TN<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>TN<span class="punctuation">)</span> <span class="operator">+</span> <span class="built_in">sum</span><span class="punctuation">(</span>FP<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment"># FNR = FN / (TP + FN)</span></span><br><span class="line">    FNR <span class="operator">=</span> <span class="built_in">sum</span><span class="punctuation">(</span>FN<span class="punctuation">)</span> <span class="operator">/</span> <span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>TP<span class="punctuation">)</span> <span class="operator">+</span> <span class="built_in">sum</span><span class="punctuation">(</span>FN<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120128191.png"></p>
<h2 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h2><blockquote>
<p>Change the threshold of the model from Exercise 1 such that the false positive rate is lower than the false negative rate. What is one reason you might do this in practice?</p>
<p>将练习 1 中的模型阈值进行调整，使得假阳性率低于假阴性率。在实际应用中，这样做的原因可能是什么？</p>
</blockquote>
<p>似乎练习题有点问题，应该要求假阳性高于假阴性，因为0.5阈值下假阳性就是低于假阴性的。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prediction<span class="operator">$</span>set_threshold<span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">)</span></span><br><span class="line">prediction<span class="operator">$</span>score<span class="punctuation">(</span>measures<span class="punctuation">)</span>  <span class="operator">%&gt;%</span> as.data.frame<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lenardar/picgo4siyuan/main/20250519120142559.png"></p>
<p>阈值的设定应该考虑我们的目标，比如控制传染，检测成本低，那么应该考虑降低假阴性，尽可能减少传播。</p>
<p>‍</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/lenardar">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%EF%BC%88Task%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">任务（Task）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">构建任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2"><span class="toc-number">1.2.</span> <span class="toc-text">数据检索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">修改任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%99%A8%EF%BC%88Learners%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">学习器（Learners）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83"><span class="toc-number">2.1.</span> <span class="toc-text">训练</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86"><span class="toc-number">2.2.</span> <span class="toc-text">数据集划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B"><span class="toc-number">2.3.</span> <span class="toc-text">预测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E9%A2%84%E6%B5%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">更改预测类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">超参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Paradox-%E4%B8%8E%E5%8F%82%E6%95%B0%E9%9B%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">Paradox 与参数集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%8E%E8%AE%BE%E7%BD%AE%E8%B6%85%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">2.5.2.</span> <span class="toc-text">获取与设置超参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.3.</span> <span class="toc-text">超参数依赖关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%BA%BF%E5%AD%A6%E4%B9%A0%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">基线学习器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0"><span class="toc-number">3.</span> <span class="toc-text">评估</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">度量指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%BE%97%E5%88%86"><span class="toc-number">3.2.</span> <span class="toc-text">预测得分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">3.3.</span> <span class="toc-text">技术指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%9B%9E%E5%BD%92"><span class="toc-number">4.</span> <span class="toc-text">测试回归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%EF%BC%88Classification%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">分类（Classification）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">测试分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.2.</span> <span class="toc-text">分类任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0%E5%99%A8%E4%B8%8E%E5%88%86%E7%B1%BB%E5%BA%A6%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">分类学习器与分类度量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PredictionClassif-%E3%80%81%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%98%88%E5%80%BC%E8%AE%BE%E5%AE%9A"><span class="toc-number">5.4.</span> <span class="toc-text">PredictionClassif 、混淆矩阵与阈值设定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5"><span class="toc-number">5.4.1.</span> <span class="toc-text">混淆矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%AE%9A%E9%98%88%E5%80%BC"><span class="toc-number">5.4.2.</span> <span class="toc-text">设定阈值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A7%92%E8%89%B2%EF%BC%88Task-Column-Roles%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">任务列角色（Task Column Roles）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">8.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01"><span class="toc-number">8.1.</span> <span class="toc-text">练习1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A02"><span class="toc-number">8.2.</span> <span class="toc-text">练习2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A03"><span class="toc-number">8.3.</span> <span class="toc-text">练习3</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&text=mlr3verse 基础建模"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&is_video=false&description=mlr3verse 基础建模"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=mlr3verse 基础建模&body=Check out this article: http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&title=mlr3verse 基础建模"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&name=mlr3verse 基础建模&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://lenardar.github.io/2025/05/19/mlr3verse-%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1/&t=mlr3verse 基础建模"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2025
    Lenardar
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/lenardar">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
